{"functions":[{"name":"OnPluginStart","docStart":4128,"docEnd":4433,"docs":{"brief":"Called when the plugin is fully initialized and all known external references are resolved. This is only called once in the lifetime of the plugin, and is paired with OnPluginEnd(). \n If any run-time error is thrown during this callback, the plugin will be marked as failed.","tags":[{"tag":"","text":"Called when the plugin is fully initialized and all known external references are resolved. This is only called once in the lifetime of the plugin, and is paired with OnPluginEnd(). \n If any run-time error is thrown during this callback, the plugin will be marked as failed."}]},"kind":"forward","returnType":"void","arguments":[]},{"name":"AskPluginLoad","docStart":0,"docEnd":0,"docs":null,"kind":"forward","returnType":"bool","arguments":[{"type":"Handle","name":"myself","decl":"Handle myself"},{"type":"bool","name":"late","decl":"bool late"},{"type":"char[]","name":"error","decl":"char[] error"},{"type":"int","name":"err_max","decl":"int err_max"}]},{"name":"AskPluginLoad2","docStart":4813,"docEnd":5953,"docs":{"brief":"Called before OnPluginStart, in case the plugin wants to check for load failure. This is called even if the plugin type is \"private.\"  Any natives from modules are not available at this point.  Thus, this forward should only be used for explicit pre-emptive things, such as adding dynamic natives, setting certain types of load filters (such as not loading the plugin for certain games).","tags":[{"tag":"","text":"Called before OnPluginStart, in case the plugin wants to check for load failure. This is called even if the plugin type is \"private.\"  Any natives from modules are not available at this point.  Thus, this forward should only be used for explicit pre-emptive things, such as adding dynamic natives, setting certain types of load filters (such as not loading the plugin for certain games)."},{"tag":"note","text":"Called before OnPluginStart, in case the plugin wants to check for load failure. This is called even if the plugin type is \"private.\"  Any natives from modules are not available at this point.  Thus, this forward should only be used for explicit pre-emptive things, such as adding dynamic natives, setting certain types of load filters (such as not loading the plugin for certain games). \n It is not safe to call externally resolved natives until OnPluginStart()."},{"tag":"note","text":"Called before OnPluginStart, in case the plugin wants to check for load failure. This is called even if the plugin type is \"private.\"  Any natives from modules are not available at this point.  Thus, this forward should only be used for explicit pre-emptive things, such as adding dynamic natives, setting certain types of load filters (such as not loading the plugin for certain games). \n It is not safe to call externally resolved natives until OnPluginStart(). Any sort of RTE in this function will cause the plugin to fail loading."},{"tag":"note","text":"Called before OnPluginStart, in case the plugin wants to check for load failure. This is called even if the plugin type is \"private.\"  Any natives from modules are not available at this point.  Thus, this forward should only be used for explicit pre-emptive things, such as adding dynamic natives, setting certain types of load filters (such as not loading the plugin for certain games). \n It is not safe to call externally resolved natives until OnPluginStart(). Any sort of RTE in this function will cause the plugin to fail loading. If you do not return anything, it is treated like returning success."},{"tag":"note","text":"Called before OnPluginStart, in case the plugin wants to check for load failure. This is called even if the plugin type is \"private.\"  Any natives from modules are not available at this point.  Thus, this forward should only be used for explicit pre-emptive things, such as adding dynamic natives, setting certain types of load filters (such as not loading the plugin for certain games). \n It is not safe to call externally resolved natives until OnPluginStart(). Any sort of RTE in this function will cause the plugin to fail loading. If you do not return anything, it is treated like returning success. If a plugin has an AskPluginLoad2(), AskPluginLoad() will not be called."},{"tag":"param:myself","text":"Called before OnPluginStart, in case the plugin wants to check for load failure. This is called even if the plugin type is \"private.\"  Any natives from modules are not available at this point.  Thus, this forward should only be used for explicit pre-emptive things, such as adding dynamic natives, setting certain types of load filters (such as not loading the plugin for certain games). \n It is not safe to call externally resolved natives until OnPluginStart(). Any sort of RTE in this function will cause the plugin to fail loading. If you do not return anything, it is treated like returning success. If a plugin has an AskPluginLoad2(), AskPluginLoad() will not be called. \n Handle to the plugin."},{"tag":"param:late","text":"Called before OnPluginStart, in case the plugin wants to check for load failure. This is called even if the plugin type is \"private.\"  Any natives from modules are not available at this point.  Thus, this forward should only be used for explicit pre-emptive things, such as adding dynamic natives, setting certain types of load filters (such as not loading the plugin for certain games). \n It is not safe to call externally resolved natives until OnPluginStart(). Any sort of RTE in this function will cause the plugin to fail loading. If you do not return anything, it is treated like returning success. If a plugin has an AskPluginLoad2(), AskPluginLoad() will not be called. \n Handle to the plugin. Whether or not the plugin was loaded \"late\" (after map load)."},{"tag":"param:error","text":"Called before OnPluginStart, in case the plugin wants to check for load failure. This is called even if the plugin type is \"private.\"  Any natives from modules are not available at this point.  Thus, this forward should only be used for explicit pre-emptive things, such as adding dynamic natives, setting certain types of load filters (such as not loading the plugin for certain games). \n It is not safe to call externally resolved natives until OnPluginStart(). Any sort of RTE in this function will cause the plugin to fail loading. If you do not return anything, it is treated like returning success. If a plugin has an AskPluginLoad2(), AskPluginLoad() will not be called. \n Handle to the plugin. Whether or not the plugin was loaded \"late\" (after map load). Error message buffer in case load failed."},{"tag":"param:err_max","text":"Called before OnPluginStart, in case the plugin wants to check for load failure. This is called even if the plugin type is \"private.\"  Any natives from modules are not available at this point.  Thus, this forward should only be used for explicit pre-emptive things, such as adding dynamic natives, setting certain types of load filters (such as not loading the plugin for certain games). \n It is not safe to call externally resolved natives until OnPluginStart(). Any sort of RTE in this function will cause the plugin to fail loading. If you do not return anything, it is treated like returning success. If a plugin has an AskPluginLoad2(), AskPluginLoad() will not be called. \n Handle to the plugin. Whether or not the plugin was loaded \"late\" (after map load). Error message buffer in case load failed. Maximum number of characters for error message buffer."},{"tag":"return","text":"Called before OnPluginStart, in case the plugin wants to check for load failure. This is called even if the plugin type is \"private.\"  Any natives from modules are not available at this point.  Thus, this forward should only be used for explicit pre-emptive things, such as adding dynamic natives, setting certain types of load filters (such as not loading the plugin for certain games). \n It is not safe to call externally resolved natives until OnPluginStart(). Any sort of RTE in this function will cause the plugin to fail loading. If you do not return anything, it is treated like returning success. If a plugin has an AskPluginLoad2(), AskPluginLoad() will not be called. \n Handle to the plugin. Whether or not the plugin was loaded \"late\" (after map load). Error message buffer in case load failed. Maximum number of characters for error message buffer. APLRes_Success for load success, APLRes_Failure or APLRes_SilentFailure otherwise"}]},"kind":"forward","returnType":"APLRes","arguments":[{"type":"Handle","name":"myself","decl":"Handle myself"},{"type":"bool","name":"late","decl":"bool late"},{"type":"char[]","name":"error","decl":"char[] error"},{"type":"int","name":"err_max","decl":"int err_max"}]},{"name":"OnPluginEnd","docStart":6042,"docEnd":6287,"docs":{"brief":"Called when the plugin is about to be unloaded. \n It is not necessary to close any handles or remove hooks in this function. SourceMod guarantees that plugin shutdown automatically and correctly releases all resources.","tags":[{"tag":"","text":"Called when the plugin is about to be unloaded. \n It is not necessary to close any handles or remove hooks in this function. SourceMod guarantees that plugin shutdown automatically and correctly releases all resources."}]},"kind":"forward","returnType":"void","arguments":[]},{"name":"OnPluginPauseChange","docStart":6320,"docEnd":6465,"docs":{"brief":"Called when the plugin's pause status is changing.","tags":[{"tag":"","text":"Called when the plugin's pause status is changing."},{"tag":"param:pause","text":"Called when the plugin's pause status is changing. \n True if the plugin is being paused, false otherwise."}]},"kind":"forward","returnType":"void","arguments":[{"type":"bool","name":"pause","decl":"bool pause"}]},{"name":"OnGameFrame","docStart":6516,"docEnd":6656,"docs":{"brief":"Called before every server frame.  Note that you should avoid doing expensive computations or declaring large local arrays.","tags":[{"tag":"","text":"Called before every server frame.  Note that you should avoid doing expensive computations or declaring large local arrays."}]},"kind":"forward","returnType":"void","arguments":[]},{"name":"OnMapStart","docStart":6689,"docEnd":6860,"docs":{"brief":"Called when the map is loaded.","tags":[{"tag":"","text":"Called when the map is loaded."},{"tag":"note","text":"Called when the map is loaded. \n This used to be OnServerLoad(), which is now deprecated. Plugins still using the old forward will work."}]},"kind":"forward","returnType":"void","arguments":[]},{"name":"OnMapEnd","docStart":6892,"docEnd":6936,"docs":{"brief":"Called right before a map ends.","tags":[{"tag":"","text":"Called right before a map ends."}]},"kind":"forward","returnType":"void","arguments":[]},{"name":"OnConfigsExecuted","docStart":6966,"docEnd":7310,"docs":{"brief":"Called when the map has loaded, servercfgfile (server.cfg) has been executed, and all plugin configs are done executing.  This is the best place to initialize plugin functions which are based on cvar data.","tags":[{"tag":"","text":"Called when the map has loaded, servercfgfile (server.cfg) has been executed, and all plugin configs are done executing.  This is the best place to initialize plugin functions which are based on cvar data."},{"tag":"note","text":"Called when the map has loaded, servercfgfile (server.cfg) has been executed, and all plugin configs are done executing.  This is the best place to initialize plugin functions which are based on cvar data. \n This will always be called once and only once per map.  It will be called after OnMapStart()."}]},"kind":"forward","returnType":"void","arguments":[]},{"name":"OnAutoConfigsBuffered","docStart":7349,"docEnd":7914,"docs":{"brief":"This is called once, right after OnMapStart() but any time before OnConfigsExecuted().  It is called after the \"exec sourcemod.cfg\" command and all AutoExecConfig() exec commands have been added to the ServerCommand() buffer. \n If you need to load per-map settings that override default values, adding commands to the ServerCommand() buffer here will guarantee that they're set before OnConfigsExecuted(). \n Unlike OnMapStart() and OnConfigsExecuted(), this is not called on late loads that occur after OnMapStart().","tags":[{"tag":"","text":"This is called once, right after OnMapStart() but any time before OnConfigsExecuted().  It is called after the \"exec sourcemod.cfg\" command and all AutoExecConfig() exec commands have been added to the ServerCommand() buffer. \n If you need to load per-map settings that override default values, adding commands to the ServerCommand() buffer here will guarantee that they're set before OnConfigsExecuted(). \n Unlike OnMapStart() and OnConfigsExecuted(), this is not called on late loads that occur after OnMapStart()."}]},"kind":"forward","returnType":"void","arguments":[]},{"name":"OnServerCfg","docStart":0,"docEnd":0,"docs":null,"kind":"forward","returnType":"void","arguments":[]},{"name":"OnAllPluginsLoaded","docStart":8108,"docEnd":8288,"docs":{"brief":"Called after all plugins have been loaded.  This is called once for every plugin.  If a plugin late loads, it will be called immediately after OnPluginStart().","tags":[{"tag":"","text":"Called after all plugins have been loaded.  This is called once for every plugin.  If a plugin late loads, it will be called immediately after OnPluginStart()."}]},"kind":"forward","returnType":"void","arguments":[]},{"name":"GetMyHandle","docStart":8328,"docEnd":8436,"docs":{"brief":"Returns the calling plugin's Handle.","tags":[{"tag":"","text":"Returns the calling plugin's Handle."},{"tag":"return","text":"Returns the calling plugin's Handle. \n Handle of the calling plugin."}]},"kind":"native","returnType":"Handle","arguments":[]},{"name":"GetPluginIterator","docStart":8470,"docEnd":8700,"docs":{"brief":"Returns an iterator that can be used to search through plugins.","tags":[{"tag":"","text":"Returns an iterator that can be used to search through plugins."},{"tag":"return","text":"Returns an iterator that can be used to search through plugins. \n Handle to iterate with.  Must be closed via CloseHandle()."},{"tag":"error","text":"Returns an iterator that can be used to search through plugins. \n Handle to iterate with.  Must be closed via CloseHandle(). Invalid Handle."}]},"kind":"native","returnType":"Handle","arguments":[]},{"name":"MorePlugins","docStart":8740,"docEnd":8983,"docs":{"brief":"Returns whether there are more plugins available in the iterator.","tags":[{"tag":"","text":"Returns whether there are more plugins available in the iterator."},{"tag":"param:iter","text":"Returns whether there are more plugins available in the iterator. \n Handle to the plugin iterator."},{"tag":"return","text":"Returns whether there are more plugins available in the iterator. \n Handle to the plugin iterator. True on more plugins, false otherwise."},{"tag":"error","text":"Returns whether there are more plugins available in the iterator. \n Handle to the plugin iterator. True on more plugins, false otherwise. Invalid Handle."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"iter","decl":"Handle iter"}]},{"name":"ReadPlugin","docStart":9026,"docEnd":9327,"docs":{"brief":"Returns the current plugin in the iterator and advances the iterator.","tags":[{"tag":"","text":"Returns the current plugin in the iterator and advances the iterator."},{"tag":"param:iter","text":"Returns the current plugin in the iterator and advances the iterator. \n Handle to the plugin iterator."},{"tag":"return","text":"Returns the current plugin in the iterator and advances the iterator. \n Handle to the plugin iterator. Current plugin the iterator is at, before the iterator is advanced."},{"tag":"error","text":"Returns the current plugin in the iterator and advances the iterator. \n Handle to the plugin iterator. Current plugin the iterator is at, before the iterator is advanced. Invalid Handle."}]},"kind":"native","returnType":"Handle","arguments":[{"type":"Handle","name":"iter","decl":"Handle iter"}]},{"name":"GetPluginStatus","docStart":9371,"docEnd":9589,"docs":{"brief":"Returns a plugin's status.","tags":[{"tag":"","text":"Returns a plugin's status."},{"tag":"param:plugin","text":"Returns a plugin's status. \n Plugin Handle (INVALID_HANDLE uses the calling plugin)."},{"tag":"return","text":"Returns a plugin's status. \n Plugin Handle (INVALID_HANDLE uses the calling plugin). Status code for the plugin."},{"tag":"error","text":"Returns a plugin's status. \n Plugin Handle (INVALID_HANDLE uses the calling plugin). Status code for the plugin. Invalid Handle."}]},"kind":"native","returnType":"PluginStatus","arguments":[{"type":"Handle","name":"plugin","decl":"Handle plugin"}]},{"name":"GetPluginFilename","docStart":9646,"docEnd":9967,"docs":{"brief":"Retrieves a plugin's file name relative to the plugins folder.","tags":[{"tag":"","text":"Retrieves a plugin's file name relative to the plugins folder."},{"tag":"param:plugin","text":"Retrieves a plugin's file name relative to the plugins folder. \n Plugin Handle (INVALID_HANDLE uses the calling plugin)."},{"tag":"param:buffer","text":"Retrieves a plugin's file name relative to the plugins folder. \n Plugin Handle (INVALID_HANDLE uses the calling plugin). Buffer to the store the file name."},{"tag":"param:maxlength","text":"Retrieves a plugin's file name relative to the plugins folder. \n Plugin Handle (INVALID_HANDLE uses the calling plugin). Buffer to the store the file name. Maximum length of the name buffer."},{"tag":"error","text":"Retrieves a plugin's file name relative to the plugins folder. \n Plugin Handle (INVALID_HANDLE uses the calling plugin). Buffer to the store the file name. Maximum length of the name buffer. Invalid Handle."}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"plugin","decl":"Handle plugin"},{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlength","decl":"int maxlength"}]},{"name":"IsPluginDebugging","docStart":10048,"docEnd":10305,"docs":{"brief":"Retrieves whether or not a plugin is being debugged.","tags":[{"tag":"","text":"Retrieves whether or not a plugin is being debugged."},{"tag":"param:plugin","text":"Retrieves whether or not a plugin is being debugged. \n Plugin Handle (INVALID_HANDLE uses the calling plugin)."},{"tag":"return","text":"Retrieves whether or not a plugin is being debugged. \n Plugin Handle (INVALID_HANDLE uses the calling plugin). True if being debugged, false otherwise."},{"tag":"error","text":"Retrieves whether or not a plugin is being debugged. \n Plugin Handle (INVALID_HANDLE uses the calling plugin). True if being debugged, false otherwise. Invalid Handle."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"plugin","decl":"Handle plugin"}]},{"name":"GetPluginInfo","docStart":10356,"docEnd":10766,"docs":{"brief":"Retrieves a plugin's public info.","tags":[{"tag":"","text":"Retrieves a plugin's public info."},{"tag":"param:plugin","text":"Retrieves a plugin's public info. \n Plugin Handle (INVALID_HANDLE uses the calling plugin)."},{"tag":"param:info","text":"Retrieves a plugin's public info. \n Plugin Handle (INVALID_HANDLE uses the calling plugin). Plugin info property to retrieve."},{"tag":"param:buffer","text":"Retrieves a plugin's public info. \n Plugin Handle (INVALID_HANDLE uses the calling plugin). Plugin info property to retrieve. Buffer to store info in."},{"tag":"param:maxlength","text":"Retrieves a plugin's public info. \n Plugin Handle (INVALID_HANDLE uses the calling plugin). Plugin info property to retrieve. Buffer to store info in. Maximum length of buffer."},{"tag":"return","text":"Retrieves a plugin's public info. \n Plugin Handle (INVALID_HANDLE uses the calling plugin). Plugin info property to retrieve. Buffer to store info in. Maximum length of buffer. True on success, false if property is not available."},{"tag":"error","text":"Retrieves a plugin's public info. \n Plugin Handle (INVALID_HANDLE uses the calling plugin). Plugin info property to retrieve. Buffer to store info in. Maximum length of buffer. True on success, false if property is not available. Invalid Handle."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"plugin","decl":"Handle plugin"},{"type":"PluginInfo","name":"info","decl":"PluginInfo info"},{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlength","decl":"int maxlength"}]},{"name":"FindPluginByNumber","docStart":10860,"docEnd":11368,"docs":{"brief":"Finds a plugin by its order in the list from the \"plugins list\" server \"sm\" command.  You should not use this function to loop through all plugins, use the iterator instead.  Looping through all plugins using this native is O(n^2), whereas using the iterator is O(n).","tags":[{"tag":"","text":"Finds a plugin by its order in the list from the \"plugins list\" server \"sm\" command.  You should not use this function to loop through all plugins, use the iterator instead.  Looping through all plugins using this native is O(n^2), whereas using the iterator is O(n)."},{"tag":"param:order_num","text":"Finds a plugin by its order in the list from the \"plugins list\" server \"sm\" command.  You should not use this function to loop through all plugins, use the iterator instead.  Looping through all plugins using this native is O(n^2), whereas using the iterator is O(n). \n Number of the plugin as it appears in \"sm plugins list\"."},{"tag":"return","text":"Finds a plugin by its order in the list from the \"plugins list\" server \"sm\" command.  You should not use this function to loop through all plugins, use the iterator instead.  Looping through all plugins using this native is O(n^2), whereas using the iterator is O(n). \n Number of the plugin as it appears in \"sm plugins list\". Plugin Handle on success, INVALID_HANDLE if no plugin matches the given number."}]},"kind":"native","returnType":"Handle","arguments":[{"type":"int","name":"order_num","decl":"int order_num"}]},{"name":"SetFailState","docStart":11422,"docEnd":12145,"docs":{"brief":"Causes the plugin to enter a failed state.  An error will be thrown and the plugin will be paused until it is unloaded or reloaded. \n For backwards compatibility, if no extra arguments are passed, no formatting is applied.  If one or more additional arguments is passed, the string is formatted using Format().  If any errors are encountered during formatting, both the format specifier string and an additional error message are written. \n This function does not return, and no further code in the plugin is executed.","tags":[{"tag":"","text":"Causes the plugin to enter a failed state.  An error will be thrown and the plugin will be paused until it is unloaded or reloaded. \n For backwards compatibility, if no extra arguments are passed, no formatting is applied.  If one or more additional arguments is passed, the string is formatted using Format().  If any errors are encountered during formatting, both the format specifier string and an additional error message are written. \n This function does not return, and no further code in the plugin is executed."},{"tag":"param:string","text":"Causes the plugin to enter a failed state.  An error will be thrown and the plugin will be paused until it is unloaded or reloaded. \n For backwards compatibility, if no extra arguments are passed, no formatting is applied.  If one or more additional arguments is passed, the string is formatted using Format().  If any errors are encountered during formatting, both the format specifier string and an additional error message are written. \n This function does not return, and no further code in the plugin is executed. \n Format specifier string."},{"tag":"param:...","text":"Causes the plugin to enter a failed state.  An error will be thrown and the plugin will be paused until it is unloaded or reloaded. \n For backwards compatibility, if no extra arguments are passed, no formatting is applied.  If one or more additional arguments is passed, the string is formatted using Format().  If any errors are encountered during formatting, both the format specifier string and an additional error message are written. \n This function does not return, and no further code in the plugin is executed. \n Format specifier string. Formatting arguments."},{"tag":"error","text":"Causes the plugin to enter a failed state.  An error will be thrown and the plugin will be paused until it is unloaded or reloaded. \n For backwards compatibility, if no extra arguments are passed, no formatting is applied.  If one or more additional arguments is passed, the string is formatted using Format().  If any errors are encountered during formatting, both the format specifier string and an additional error message are written. \n This function does not return, and no further code in the plugin is executed. \n Format specifier string. Formatting arguments. Always throws SP_ERROR_ABORT."}]},"kind":"native","returnType":"void","arguments":[{"type":"const char[]","name":"string","decl":"const char[] string"},{"type":"any...","name":"...","decl":"any... ..."}]},{"name":"ThrowError","docStart":12206,"docEnd":12464,"docs":{"brief":"Aborts the current callback and throws an error.  This function does not return in that no code is executed following it.","tags":[{"tag":"","text":"Aborts the current callback and throws an error.  This function does not return in that no code is executed following it."},{"tag":"param:fmt","text":"Aborts the current callback and throws an error.  This function does not return in that no code is executed following it. \n String format."},{"tag":"param:...","text":"Aborts the current callback and throws an error.  This function does not return in that no code is executed following it. \n String format. Format arguments."},{"tag":"error","text":"Aborts the current callback and throws an error.  This function does not return in that no code is executed following it. \n String format. Format arguments. Always!"}]},"kind":"native","returnType":"void","arguments":[{"type":"const char[]","name":"fmt","decl":"const char[] fmt"},{"type":"any...","name":"...","decl":"any... ..."}]},{"name":"LogStackTrace","docStart":12520,"docEnd":12795,"docs":{"brief":"Logs a stack trace from the current function call. Code execution continues after the call","tags":[{"tag":"","text":"Logs a stack trace from the current function call. Code execution continues after the call"},{"tag":"param:fmt","text":"Logs a stack trace from the current function call. Code execution continues after the call \n Format string to send with the stack trace."},{"tag":"param:...","text":"Logs a stack trace from the current function call. Code execution continues after the call \n Format string to send with the stack trace. Format arguments."},{"tag":"error","text":"Logs a stack trace from the current function call. Code execution continues after the call \n Format string to send with the stack trace. Format arguments. Always logs a stack trace."}]},"kind":"native","returnType":"void","arguments":[{"type":"const char[]","name":"fmt","decl":"const char[] fmt"},{"type":"any...","name":"...","decl":"any... ..."}]},{"name":"GetTime","docStart":12854,"docEnd":13064,"docs":{"brief":"Gets the system time as a unix timestamp.","tags":[{"tag":"","text":"Gets the system time as a unix timestamp."},{"tag":"param:bigStamp","text":"Gets the system time as a unix timestamp. \n Optional array to store the 64bit timestamp in."},{"tag":"return","text":"Gets the system time as a unix timestamp. \n Optional array to store the 64bit timestamp in. 32bit timestamp (number of seconds since unix epoch)."}]},"kind":"native","returnType":"int","arguments":[{"type":"int[2]","name":"bigStamp","decl":"int bigStamp[2]"}]},{"name":"FormatTime","docStart":13112,"docEnd":13868,"docs":{"brief":"Produces a date and/or time string value for a timestamp. \n See this URL for valid parameters: http://cplusplus.com/reference/clibrary/ctime/strftime.html \n Note that available parameters depends on support from your operating system. In particular, ones highlighted in yellow on that page are not currently available on Windows and should be avoided for portable plugins.","tags":[{"tag":"","text":"Produces a date and/or time string value for a timestamp. \n See this URL for valid parameters: http://cplusplus.com/reference/clibrary/ctime/strftime.html \n Note that available parameters depends on support from your operating system. In particular, ones highlighted in yellow on that page are not currently available on Windows and should be avoided for portable plugins."},{"tag":"param:buffer","text":"Produces a date and/or time string value for a timestamp. \n See this URL for valid parameters: http://cplusplus.com/reference/clibrary/ctime/strftime.html \n Note that available parameters depends on support from your operating system. In particular, ones highlighted in yellow on that page are not currently available on Windows and should be avoided for portable plugins. \n Destination string buffer."},{"tag":"param:maxlength","text":"Produces a date and/or time string value for a timestamp. \n See this URL for valid parameters: http://cplusplus.com/reference/clibrary/ctime/strftime.html \n Note that available parameters depends on support from your operating system. In particular, ones highlighted in yellow on that page are not currently available on Windows and should be avoided for portable plugins. \n Destination string buffer. Maximum length of output string buffer."},{"tag":"param:format","text":"Produces a date and/or time string value for a timestamp. \n See this URL for valid parameters: http://cplusplus.com/reference/clibrary/ctime/strftime.html \n Note that available parameters depends on support from your operating system. In particular, ones highlighted in yellow on that page are not currently available on Windows and should be avoided for portable plugins. \n Destination string buffer. Maximum length of output string buffer. Formatting rules (passing NULL_STRING will use the rules defined in sm_datetime_format)."},{"tag":"param:stamp","text":"Produces a date and/or time string value for a timestamp. \n See this URL for valid parameters: http://cplusplus.com/reference/clibrary/ctime/strftime.html \n Note that available parameters depends on support from your operating system. In particular, ones highlighted in yellow on that page are not currently available on Windows and should be avoided for portable plugins. \n Destination string buffer. Maximum length of output string buffer. Formatting rules (passing NULL_STRING will use the rules defined in sm_datetime_format). Optional time stamp."},{"tag":"error","text":"Produces a date and/or time string value for a timestamp. \n See this URL for valid parameters: http://cplusplus.com/reference/clibrary/ctime/strftime.html \n Note that available parameters depends on support from your operating system. In particular, ones highlighted in yellow on that page are not currently available on Windows and should be avoided for portable plugins. \n Destination string buffer. Maximum length of output string buffer. Formatting rules (passing NULL_STRING will use the rules defined in sm_datetime_format). Optional time stamp. Buffer too small or invalid time format."}]},"kind":"native","returnType":"void","arguments":[{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlength","decl":"int maxlength"},{"type":"const char[]","name":"format","decl":"const char[] format"},{"type":"int","name":"stamp","decl":"int stamp"}]},{"name":"LoadGameConfigFile","docStart":13962,"docEnd":14269,"docs":{"brief":"Loads a game config file.","tags":[{"tag":"","text":"Loads a game config file."},{"tag":"param:file","text":"Loads a game config file. \n File to load.  The path must be relative to the 'gamedata' folder under the config folder and the extension should be omitted."},{"tag":"return","text":"Loads a game config file. \n File to load.  The path must be relative to the 'gamedata' folder under the config folder and the extension should be omitted. A handle to the game config file or INVALID_HANDLE on failure."}]},"kind":"native","returnType":"GameData","arguments":[{"type":"const char[]","name":"file","decl":"const char[] file"}]},{"name":"GameConfGetOffset","docStart":14329,"docEnd":14535,"docs":{"brief":"Returns an offset value.","tags":[{"tag":"","text":"Returns an offset value."},{"tag":"param:gc","text":"Returns an offset value. \n Game config handle."},{"tag":"param:key","text":"Returns an offset value. \n Game config handle. Key to retrieve from the offset section."},{"tag":"return","text":"Returns an offset value. \n Game config handle. Key to retrieve from the offset section. An offset, or -1 on failure."}]},"kind":"native","returnType":"int","arguments":[{"type":"Handle","name":"gc","decl":"Handle gc"},{"type":"const char[]","name":"key","decl":"const char[] key"}]},{"name":"GameConfGetKeyValue","docStart":14599,"docEnd":14953,"docs":{"brief":"Gets the value of a key from the \"Keys\" section.","tags":[{"tag":"","text":"Gets the value of a key from the \"Keys\" section."},{"tag":"param:gc","text":"Gets the value of a key from the \"Keys\" section. \n Game config handle."},{"tag":"param:key","text":"Gets the value of a key from the \"Keys\" section. \n Game config handle. Key to retrieve from the Keys section."},{"tag":"param:buffer","text":"Gets the value of a key from the \"Keys\" section. \n Game config handle. Key to retrieve from the Keys section. Destination string buffer."},{"tag":"param:maxlen","text":"Gets the value of a key from the \"Keys\" section. \n Game config handle. Key to retrieve from the Keys section. Destination string buffer. Maximum length of output string buffer."},{"tag":"return","text":"Gets the value of a key from the \"Keys\" section. \n Game config handle. Key to retrieve from the Keys section. Destination string buffer. Maximum length of output string buffer. True if key existed, false otherwise."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"gc","decl":"Handle gc"},{"type":"const char[]","name":"key","decl":"const char[] key"},{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlen","decl":"int maxlen"}]},{"name":"GameConfGetAddress","docStart":15047,"docEnd":15373,"docs":{"brief":"Finds an address calculation in a GameConfig file, performs LoadFromAddress on it as appropriate, then returns the final address.","tags":[{"tag":"","text":"Finds an address calculation in a GameConfig file, performs LoadFromAddress on it as appropriate, then returns the final address."},{"tag":"param:gameconf","text":"Finds an address calculation in a GameConfig file, performs LoadFromAddress on it as appropriate, then returns the final address. \n Game config handle."},{"tag":"param:name","text":"Finds an address calculation in a GameConfig file, performs LoadFromAddress on it as appropriate, then returns the final address. \n Game config handle. Name of the property to find."},{"tag":"return","text":"Finds an address calculation in a GameConfig file, performs LoadFromAddress on it as appropriate, then returns the final address. \n Game config handle. Name of the property to find. An address calculated on success, or 0 on failure."}]},"kind":"native","returnType":"Address","arguments":[{"type":"Handle","name":"gameconf","decl":"Handle gameconf"},{"type":"const char[]","name":"name","decl":"const char[] name"}]},{"name":"GetSysTickCount","docStart":15449,"docEnd":15680,"docs":{"brief":"Returns the operating system's \"tick count,\" which is a number of milliseconds since the operating system loaded.  This can be used for basic benchmarks.","tags":[{"tag":"","text":"Returns the operating system's \"tick count,\" which is a number of milliseconds since the operating system loaded.  This can be used for basic benchmarks."},{"tag":"return","text":"Returns the operating system's \"tick count,\" which is a number of milliseconds since the operating system loaded.  This can be used for basic benchmarks. \n Tick count in milliseconds."}]},"kind":"native","returnType":"int","arguments":[]},{"name":"AutoExecConfig","docStart":15715,"docEnd":16404,"docs":{"brief":"Specifies that the given config file should be executed after plugin load. OnConfigsExecuted() will not be called until the config file has executed, but it will be called if the execution fails.","tags":[{"tag":"","text":"Specifies that the given config file should be executed after plugin load. OnConfigsExecuted() will not be called until the config file has executed, but it will be called if the execution fails."},{"tag":"param:autoCreate","text":"Specifies that the given config file should be executed after plugin load. OnConfigsExecuted() will not be called until the config file has executed, but it will be called if the execution fails. \n If true, and the config file does not exist, such a config file will be automatically created and populated with information from the plugin's registered cvars."},{"tag":"param:name","text":"Specifies that the given config file should be executed after plugin load. OnConfigsExecuted() will not be called until the config file has executed, but it will be called if the execution fails. \n If true, and the config file does not exist, such a config file will be automatically created and populated with information from the plugin's registered cvars. Name of the config file, excluding the .cfg extension. If empty, <plugin.filename.cfg> is assumed."},{"tag":"param:folder","text":"Specifies that the given config file should be executed after plugin load. OnConfigsExecuted() will not be called until the config file has executed, but it will be called if the execution fails. \n If true, and the config file does not exist, such a config file will be automatically created and populated with information from the plugin's registered cvars. Name of the config file, excluding the .cfg extension. If empty, <plugin.filename.cfg> is assumed. Folder under cfg/ to use.  By default this is \"sourcemod.\""}]},"kind":"native","returnType":"void","arguments":[{"type":"bool","name":"autoCreate","decl":"bool autoCreate"},{"type":"const char[]","name":"name","decl":"const char[] name"},{"type":"const char[]","name":"folder","decl":"const char[] folder"}]},{"name":"RegPluginLibrary","docStart":16514,"docEnd":16648,"docs":{"brief":"Registers a library name for identifying as a dependency to other plugins.","tags":[{"tag":"","text":"Registers a library name for identifying as a dependency to other plugins."},{"tag":"param:name","text":"Registers a library name for identifying as a dependency to other plugins. \n Library name."}]},"kind":"native","returnType":"void","arguments":[{"type":"const char[]","name":"name","decl":"const char[] name"}]},{"name":"LibraryExists","docStart":16702,"docEnd":17090,"docs":{"brief":"Returns whether a library exists.  This function should be considered expensive; it should only be called on plugin to determine availability of resources.  Use OnLibraryAdded()/OnLibraryRemoved() to detect changes in optional resources.","tags":[{"tag":"","text":"Returns whether a library exists.  This function should be considered expensive; it should only be called on plugin to determine availability of resources.  Use OnLibraryAdded()/OnLibraryRemoved() to detect changes in optional resources."},{"tag":"param:name","text":"Returns whether a library exists.  This function should be considered expensive; it should only be called on plugin to determine availability of resources.  Use OnLibraryAdded()/OnLibraryRemoved() to detect changes in optional resources. \n Library name of a plugin or extension."},{"tag":"return","text":"Returns whether a library exists.  This function should be considered expensive; it should only be called on plugin to determine availability of resources.  Use OnLibraryAdded()/OnLibraryRemoved() to detect changes in optional resources. \n Library name of a plugin or extension. True if exists, false otherwise."}]},"kind":"native","returnType":"bool","arguments":[{"type":"const char[]","name":"name","decl":"const char[] name"}]},{"name":"GetExtensionFileStatus","docStart":17141,"docEnd":17670,"docs":{"brief":"Returns the status of an extension, by filename.","tags":[{"tag":"","text":"Returns the status of an extension, by filename."},{"tag":"param:name","text":"Returns the status of an extension, by filename. \n Extension name (like \"sdktools.ext\")."},{"tag":"param:error","text":"Returns the status of an extension, by filename. \n Extension name (like \"sdktools.ext\"). Optional error message buffer."},{"tag":"param:maxlength","text":"Returns the status of an extension, by filename. \n Extension name (like \"sdktools.ext\"). Optional error message buffer. Length of optional error message buffer."},{"tag":"return","text":"Returns the status of an extension, by filename. \n Extension name (like \"sdktools.ext\"). Optional error message buffer. Length of optional error message buffer. -2 if the extension was not found. -1 if the extension was found but failed to load. 0 if the extension loaded but reported an error. 1 if the extension is running without error."}]},"kind":"native","returnType":"int","arguments":[{"type":"const char[]","name":"name","decl":"const char[] name"},{"type":"char[]","name":"error","decl":"char[] error"},{"type":"int","name":"maxlength","decl":"int maxlength"}]},{"name":"OnLibraryAdded","docStart":17763,"docEnd":17991,"docs":{"brief":"Called after a library is added that the current plugin references optionally. A library is either a plugin name or extension name, as exposed via its include file.","tags":[{"tag":"","text":"Called after a library is added that the current plugin references optionally. A library is either a plugin name or extension name, as exposed via its include file."},{"tag":"param:name","text":"Called after a library is added that the current plugin references optionally. A library is either a plugin name or extension name, as exposed via its include file. \n Library name."}]},"kind":"forward","returnType":"void","arguments":[{"type":"const char[]","name":"name","decl":"const char[] name"}]},{"name":"OnLibraryRemoved","docStart":18044,"docEnd":18282,"docs":{"brief":"Called right before a library is removed that the current plugin references optionally.  A library is either a plugin name or extension name, as exposed via its include file.","tags":[{"tag":"","text":"Called right before a library is removed that the current plugin references optionally.  A library is either a plugin name or extension name, as exposed via its include file."},{"tag":"param:name","text":"Called right before a library is removed that the current plugin references optionally.  A library is either a plugin name or extension name, as exposed via its include file. \n Library name."}]},"kind":"forward","returnType":"void","arguments":[{"type":"const char[]","name":"name","decl":"const char[] name"}]},{"name":"ReadMapList","docStart":18654,"docEnd":21817,"docs":{"brief":"Loads a map list to an ADT Array. \n A map list is a list of maps from a file.  SourceMod allows easy configuration of maplists through addons/sourcemod/configs/maplists.cfg.  Each entry is given a name and a file (for example, \"rtv\" => \"rtv.cfg\"), or a name and a redirection (for example, \"rtv\" => \"default\").  This native will read a map list entry, cache the file, and return the list of maps it holds. \n Serial change numbers are used to identify if a map list has changed.  Thus, if you pass a serial change number and it's equal to what SourceMod currently knows about the map list, then SourceMod won't re-parse the file. \n If the maps end up being read from the maps folder (MAPLIST_FLAG_MAPSFOLDER), they are automatically sorted in alphabetical, ascending order. \n Arrays created by this function are temporary and must be freed via CloseHandle(). Modifying arrays created by this function will not affect future return values or or the contents of arrays returned to other plugins.","tags":[{"tag":"","text":"Loads a map list to an ADT Array. \n A map list is a list of maps from a file.  SourceMod allows easy configuration of maplists through addons/sourcemod/configs/maplists.cfg.  Each entry is given a name and a file (for example, \"rtv\" => \"rtv.cfg\"), or a name and a redirection (for example, \"rtv\" => \"default\").  This native will read a map list entry, cache the file, and return the list of maps it holds. \n Serial change numbers are used to identify if a map list has changed.  Thus, if you pass a serial change number and it's equal to what SourceMod currently knows about the map list, then SourceMod won't re-parse the file. \n If the maps end up being read from the maps folder (MAPLIST_FLAG_MAPSFOLDER), they are automatically sorted in alphabetical, ascending order. \n Arrays created by this function are temporary and must be freed via CloseHandle(). Modifying arrays created by this function will not affect future return values or or the contents of arrays returned to other plugins."},{"tag":"param:array","text":"Loads a map list to an ADT Array. \n A map list is a list of maps from a file.  SourceMod allows easy configuration of maplists through addons/sourcemod/configs/maplists.cfg.  Each entry is given a name and a file (for example, \"rtv\" => \"rtv.cfg\"), or a name and a redirection (for example, \"rtv\" => \"default\").  This native will read a map list entry, cache the file, and return the list of maps it holds. \n Serial change numbers are used to identify if a map list has changed.  Thus, if you pass a serial change number and it's equal to what SourceMod currently knows about the map list, then SourceMod won't re-parse the file. \n If the maps end up being read from the maps folder (MAPLIST_FLAG_MAPSFOLDER), they are automatically sorted in alphabetical, ascending order. \n Arrays created by this function are temporary and must be freed via CloseHandle(). Modifying arrays created by this function will not affect future return values or or the contents of arrays returned to other plugins. \n Array to store the map list.  If INVALID_HANDLE, a new blank array will be created.  The blocksize should be at least 16; otherwise results may be truncated.  Items are added to the array as strings.  The array is never checked for duplicates, and it is not read beforehand.  Only the serial number is used to detect changes."},{"tag":"param:serial","text":"Loads a map list to an ADT Array. \n A map list is a list of maps from a file.  SourceMod allows easy configuration of maplists through addons/sourcemod/configs/maplists.cfg.  Each entry is given a name and a file (for example, \"rtv\" => \"rtv.cfg\"), or a name and a redirection (for example, \"rtv\" => \"default\").  This native will read a map list entry, cache the file, and return the list of maps it holds. \n Serial change numbers are used to identify if a map list has changed.  Thus, if you pass a serial change number and it's equal to what SourceMod currently knows about the map list, then SourceMod won't re-parse the file. \n If the maps end up being read from the maps folder (MAPLIST_FLAG_MAPSFOLDER), they are automatically sorted in alphabetical, ascending order. \n Arrays created by this function are temporary and must be freed via CloseHandle(). Modifying arrays created by this function will not affect future return values or or the contents of arrays returned to other plugins. \n Array to store the map list.  If INVALID_HANDLE, a new blank array will be created.  The blocksize should be at least 16; otherwise results may be truncated.  Items are added to the array as strings.  The array is never checked for duplicates, and it is not read beforehand.  Only the serial number is used to detect changes. Serial number to identify last known map list change.  If -1, the the value will not be checked.  If the map list has since changed, the serial is updated (even if -1 was passed).  If there is an error finding a valid maplist, then the serial is set to -1."},{"tag":"param:str","text":"Loads a map list to an ADT Array. \n A map list is a list of maps from a file.  SourceMod allows easy configuration of maplists through addons/sourcemod/configs/maplists.cfg.  Each entry is given a name and a file (for example, \"rtv\" => \"rtv.cfg\"), or a name and a redirection (for example, \"rtv\" => \"default\").  This native will read a map list entry, cache the file, and return the list of maps it holds. \n Serial change numbers are used to identify if a map list has changed.  Thus, if you pass a serial change number and it's equal to what SourceMod currently knows about the map list, then SourceMod won't re-parse the file. \n If the maps end up being read from the maps folder (MAPLIST_FLAG_MAPSFOLDER), they are automatically sorted in alphabetical, ascending order. \n Arrays created by this function are temporary and must be freed via CloseHandle(). Modifying arrays created by this function will not affect future return values or or the contents of arrays returned to other plugins. \n Array to store the map list.  If INVALID_HANDLE, a new blank array will be created.  The blocksize should be at least 16; otherwise results may be truncated.  Items are added to the array as strings.  The array is never checked for duplicates, and it is not read beforehand.  Only the serial number is used to detect changes. Serial number to identify last known map list change.  If -1, the the value will not be checked.  If the map list has since changed, the serial is updated (even if -1 was passed).  If there is an error finding a valid maplist, then the serial is set to -1. Config name, or \"default\" for the default map list.  Config names should be somewhat descriptive.  For example, the admin menu uses a config name of \"admin menu\".  The list names can be configured by users in addons/sourcemod/configs/maplists.cfg."},{"tag":"param:flags","text":"Loads a map list to an ADT Array. \n A map list is a list of maps from a file.  SourceMod allows easy configuration of maplists through addons/sourcemod/configs/maplists.cfg.  Each entry is given a name and a file (for example, \"rtv\" => \"rtv.cfg\"), or a name and a redirection (for example, \"rtv\" => \"default\").  This native will read a map list entry, cache the file, and return the list of maps it holds. \n Serial change numbers are used to identify if a map list has changed.  Thus, if you pass a serial change number and it's equal to what SourceMod currently knows about the map list, then SourceMod won't re-parse the file. \n If the maps end up being read from the maps folder (MAPLIST_FLAG_MAPSFOLDER), they are automatically sorted in alphabetical, ascending order. \n Arrays created by this function are temporary and must be freed via CloseHandle(). Modifying arrays created by this function will not affect future return values or or the contents of arrays returned to other plugins. \n Array to store the map list.  If INVALID_HANDLE, a new blank array will be created.  The blocksize should be at least 16; otherwise results may be truncated.  Items are added to the array as strings.  The array is never checked for duplicates, and it is not read beforehand.  Only the serial number is used to detect changes. Serial number to identify last known map list change.  If -1, the the value will not be checked.  If the map list has since changed, the serial is updated (even if -1 was passed).  If there is an error finding a valid maplist, then the serial is set to -1. Config name, or \"default\" for the default map list.  Config names should be somewhat descriptive.  For example, the admin menu uses a config name of \"admin menu\".  The list names can be configured by users in addons/sourcemod/configs/maplists.cfg. MAPLIST_FLAG flags."},{"tag":"return","text":"Loads a map list to an ADT Array. \n A map list is a list of maps from a file.  SourceMod allows easy configuration of maplists through addons/sourcemod/configs/maplists.cfg.  Each entry is given a name and a file (for example, \"rtv\" => \"rtv.cfg\"), or a name and a redirection (for example, \"rtv\" => \"default\").  This native will read a map list entry, cache the file, and return the list of maps it holds. \n Serial change numbers are used to identify if a map list has changed.  Thus, if you pass a serial change number and it's equal to what SourceMod currently knows about the map list, then SourceMod won't re-parse the file. \n If the maps end up being read from the maps folder (MAPLIST_FLAG_MAPSFOLDER), they are automatically sorted in alphabetical, ascending order. \n Arrays created by this function are temporary and must be freed via CloseHandle(). Modifying arrays created by this function will not affect future return values or or the contents of arrays returned to other plugins. \n Array to store the map list.  If INVALID_HANDLE, a new blank array will be created.  The blocksize should be at least 16; otherwise results may be truncated.  Items are added to the array as strings.  The array is never checked for duplicates, and it is not read beforehand.  Only the serial number is used to detect changes. Serial number to identify last known map list change.  If -1, the the value will not be checked.  If the map list has since changed, the serial is updated (even if -1 was passed).  If there is an error finding a valid maplist, then the serial is set to -1. Config name, or \"default\" for the default map list.  Config names should be somewhat descriptive.  For example, the admin menu uses a config name of \"admin menu\".  The list names can be configured by users in addons/sourcemod/configs/maplists.cfg. MAPLIST_FLAG flags. On failure: INVALID_HANDLE is returned, the serial is set to -1, and the input array (if any) is left unchanged. On no change: INVALID_HANDLE is returned, the serial is unchanged, and the input array (if any) is left unchanged. On success: A valid array Handle is returned, containing at least one map string. If an array was passed, the return value is equal to the passed Array Handle.  If the passed array was not cleared, it will have grown by at least one item.  The serial number is updated to a positive number."},{"tag":"error","text":"Loads a map list to an ADT Array. \n A map list is a list of maps from a file.  SourceMod allows easy configuration of maplists through addons/sourcemod/configs/maplists.cfg.  Each entry is given a name and a file (for example, \"rtv\" => \"rtv.cfg\"), or a name and a redirection (for example, \"rtv\" => \"default\").  This native will read a map list entry, cache the file, and return the list of maps it holds. \n Serial change numbers are used to identify if a map list has changed.  Thus, if you pass a serial change number and it's equal to what SourceMod currently knows about the map list, then SourceMod won't re-parse the file. \n If the maps end up being read from the maps folder (MAPLIST_FLAG_MAPSFOLDER), they are automatically sorted in alphabetical, ascending order. \n Arrays created by this function are temporary and must be freed via CloseHandle(). Modifying arrays created by this function will not affect future return values or or the contents of arrays returned to other plugins. \n Array to store the map list.  If INVALID_HANDLE, a new blank array will be created.  The blocksize should be at least 16; otherwise results may be truncated.  Items are added to the array as strings.  The array is never checked for duplicates, and it is not read beforehand.  Only the serial number is used to detect changes. Serial number to identify last known map list change.  If -1, the the value will not be checked.  If the map list has since changed, the serial is updated (even if -1 was passed).  If there is an error finding a valid maplist, then the serial is set to -1. Config name, or \"default\" for the default map list.  Config names should be somewhat descriptive.  For example, the admin menu uses a config name of \"admin menu\".  The list names can be configured by users in addons/sourcemod/configs/maplists.cfg. MAPLIST_FLAG flags. On failure: INVALID_HANDLE is returned, the serial is set to -1, and the input array (if any) is left unchanged. On no change: INVALID_HANDLE is returned, the serial is unchanged, and the input array (if any) is left unchanged. On success: A valid array Handle is returned, containing at least one map string. If an array was passed, the return value is equal to the passed Array Handle.  If the passed array was not cleared, it will have grown by at least one item.  The serial number is updated to a positive number. Invalid array Handle that is not INVALID_HANDLE."}]},"kind":"native","returnType":"Handle","arguments":[{"type":"Handle","name":"array","decl":"Handle array"},{"type":"int&","name":"serial","decl":"int& serial"},{"type":"const char[]","name":"str","decl":"const char[] str"},{"type":"int","name":"flags","decl":"int flags"}]},{"name":"SetMapListCompatBind","docStart":22038,"docEnd":22421,"docs":{"brief":"Makes a compatibility binding for map lists.  For example, if a function previously used \"clam.cfg\" for map lists, this function will insert a \"fake\" binding to \"clam.cfg\" that will be overridden if it's in the maplists.cfg file.","tags":[{"tag":"","text":"Makes a compatibility binding for map lists.  For example, if a function previously used \"clam.cfg\" for map lists, this function will insert a \"fake\" binding to \"clam.cfg\" that will be overridden if it's in the maplists.cfg file."},{"tag":"param:name","text":"Makes a compatibility binding for map lists.  For example, if a function previously used \"clam.cfg\" for map lists, this function will insert a \"fake\" binding to \"clam.cfg\" that will be overridden if it's in the maplists.cfg file. \n Configuration name that would be used with ReadMapList()."},{"tag":"param:file","text":"Makes a compatibility binding for map lists.  For example, if a function previously used \"clam.cfg\" for map lists, this function will insert a \"fake\" binding to \"clam.cfg\" that will be overridden if it's in the maplists.cfg file. \n Configuration name that would be used with ReadMapList(). Default file to use."}]},"kind":"native","returnType":"void","arguments":[{"type":"const char[]","name":"name","decl":"const char[] name"},{"type":"const char[]","name":"file","decl":"const char[] file"}]},{"name":"OnClientFloodCheck","docStart":22498,"docEnd":22907,"docs":{"brief":"Called when a client has sent chat text.  This must return either true or false to indicate that a client is or is not spamming the server. \n The return value is a hint only.  Core or another plugin may decide otherwise.","tags":[{"tag":"","text":"Called when a client has sent chat text.  This must return either true or false to indicate that a client is or is not spamming the server. \n The return value is a hint only.  Core or another plugin may decide otherwise."},{"tag":"param:client","text":"Called when a client has sent chat text.  This must return either true or false to indicate that a client is or is not spamming the server. \n The return value is a hint only.  Core or another plugin may decide otherwise. \n Client index.  The server (0) will never be passed."},{"tag":"return","text":"Called when a client has sent chat text.  This must return either true or false to indicate that a client is or is not spamming the server. \n The return value is a hint only.  Core or another plugin may decide otherwise. \n Client index.  The server (0) will never be passed. True if client is spamming the server, false otherwise."}]},"kind":"forward","returnType":"bool","arguments":[{"type":"int","name":"client","decl":"int client"}]},{"name":"OnClientFloodResult","docStart":22957,"docEnd":23442,"docs":{"brief":"Called after a client's flood check has been computed.  This can be used by antiflood algorithms to decay/increase flooding weights. \n Since the result from \"OnClientFloodCheck\" isn't guaranteed to be the final result, it is generally a good idea to use this to play with other algorithms nicely.","tags":[{"tag":"","text":"Called after a client's flood check has been computed.  This can be used by antiflood algorithms to decay/increase flooding weights. \n Since the result from \"OnClientFloodCheck\" isn't guaranteed to be the final result, it is generally a good idea to use this to play with other algorithms nicely."},{"tag":"param:client","text":"Called after a client's flood check has been computed.  This can be used by antiflood algorithms to decay/increase flooding weights. \n Since the result from \"OnClientFloodCheck\" isn't guaranteed to be the final result, it is generally a good idea to use this to play with other algorithms nicely. \n Client index.  The server (0) will never be passed."},{"tag":"param:blocked","text":"Called after a client's flood check has been computed.  This can be used by antiflood algorithms to decay/increase flooding weights. \n Since the result from \"OnClientFloodCheck\" isn't guaranteed to be the final result, it is generally a good idea to use this to play with other algorithms nicely. \n Client index.  The server (0) will never be passed. True if client flooded last \"say\", false otherwise."}]},"kind":"forward","returnType":"void","arguments":[{"type":"int","name":"client","decl":"int client"},{"type":"bool","name":"blocked","decl":"bool blocked"}]},{"name":"CanTestFeatures","docStart":24285,"docEnd":24600,"docs":{"brief":"Returns whether \"GetFeatureStatus\" will work. Using this native or this function will not cause SourceMod to fail loading on older versions, however, GetFeatureStatus will only work if this function returns true.","tags":[{"tag":"","text":"Returns whether \"GetFeatureStatus\" will work. Using this native or this function will not cause SourceMod to fail loading on older versions, however, GetFeatureStatus will only work if this function returns true."},{"tag":"return","text":"Returns whether \"GetFeatureStatus\" will work. Using this native or this function will not cause SourceMod to fail loading on older versions, however, GetFeatureStatus will only work if this function returns true. \n True if GetFeatureStatus will work, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[]},{"name":"GetFeatureStatus","docStart":24687,"docEnd":24889,"docs":{"brief":"Returns whether a feature exists, and if so, whether it is usable.","tags":[{"tag":"","text":"Returns whether a feature exists, and if so, whether it is usable."},{"tag":"param:type","text":"Returns whether a feature exists, and if so, whether it is usable. \n Feature type."},{"tag":"param:name","text":"Returns whether a feature exists, and if so, whether it is usable. \n Feature type. Feature name."},{"tag":"return","text":"Returns whether a feature exists, and if so, whether it is usable. \n Feature type. Feature name. Feature status."}]},"kind":"native","returnType":"FeatureStatus","arguments":[{"type":"FeatureType","name":"type","decl":"FeatureType type"},{"type":"const char[]","name":"name","decl":"const char[] name"}]},{"name":"RequireFeature","docStart":24970,"docEnd":25308,"docs":{"brief":"Requires that a given feature is available. If it is not, SetFailState() is called with the given message.","tags":[{"tag":"","text":"Requires that a given feature is available. If it is not, SetFailState() is called with the given message."},{"tag":"param:type","text":"Requires that a given feature is available. If it is not, SetFailState() is called with the given message. \n Feature type."},{"tag":"param:name","text":"Requires that a given feature is available. If it is not, SetFailState() is called with the given message. \n Feature type. Feature name."},{"tag":"param:fmt","text":"Requires that a given feature is available. If it is not, SetFailState() is called with the given message. \n Feature type. Feature name. Message format string, or empty to use default."},{"tag":"param:...","text":"Requires that a given feature is available. If it is not, SetFailState() is called with the given message. \n Feature type. Feature name. Message format string, or empty to use default. Message format parameters, if any."}]},"kind":"native","returnType":"void","arguments":[{"type":"FeatureType","name":"type","decl":"FeatureType type"},{"type":"const char[]","name":"name","decl":"const char[] name"},{"type":"const char[]","name":"fmt","decl":"const char[] fmt"},{"type":"any...","name":"...","decl":"any... ..."}]},{"name":"LoadFromAddress","docStart":25727,"docEnd":25963,"docs":{"brief":"Load up to 4 bytes from a memory address.","tags":[{"tag":"","text":"Load up to 4 bytes from a memory address."},{"tag":"param:addr","text":"Load up to 4 bytes from a memory address. \n Address to a memory location."},{"tag":"param:size","text":"Load up to 4 bytes from a memory address. \n Address to a memory location. How many bytes should be read."},{"tag":"return","text":"Load up to 4 bytes from a memory address. \n Address to a memory location. How many bytes should be read. The value that is stored at that address."}]},"kind":"native","returnType":"int","arguments":[{"type":"Address","name":"addr","decl":"Address addr"},{"type":"NumberType","name":"size","decl":"NumberType size"}]},{"name":"StoreToAddress","docStart":26027,"docEnd":26254,"docs":{"brief":"Store up to 4 bytes to a memory address.","tags":[{"tag":"","text":"Store up to 4 bytes to a memory address."},{"tag":"param:addr","text":"Store up to 4 bytes to a memory address. \n Address to a memory location."},{"tag":"param:data","text":"Store up to 4 bytes to a memory address. \n Address to a memory location. Value to store at the address."},{"tag":"param:size","text":"Store up to 4 bytes to a memory address. \n Address to a memory location. Value to store at the address. How many bytes should be written."}]},"kind":"native","returnType":"void","arguments":[{"type":"Address","name":"addr","decl":"Address addr"},{"type":"int","name":"data","decl":"int data"},{"type":"NumberType","name":"size","decl":"NumberType size"}]}],"methodmaps":[{"name":"GameData","docStart":0,"docEnd":0,"docs":null,"methods":[{"name":"GameData","docStart":2853,"docEnd":3144,"docs":{"brief":"Loads a game config file.","tags":[{"tag":"","text":"Loads a game config file."},{"tag":"param:file","text":"Loads a game config file. \n File to load.  The path must be relative to the 'gamedata' folder under the config folder and the extension should be omitted."},{"tag":"return","text":"Loads a game config file. \n File to load.  The path must be relative to the 'gamedata' folder under the config folder and the extension should be omitted. A handle to the game config file or null on failure"}]},"kind":null,"returnType":"GameData","arguments":[{"type":"const char[]","name":"file","decl":"const char[] file"}]},{"name":"GetOffset","docStart":3194,"docEnd":3348,"docs":{"brief":"Returns an offset value.","tags":[{"tag":"","text":"Returns an offset value."},{"tag":"param:key","text":"Returns an offset value. \n Key to retrieve from the offset section."},{"tag":"return","text":"Returns an offset value. \n Key to retrieve from the offset section. An offset, or -1 on failure"}]},"kind":null,"returnType":"int","arguments":[{"type":"const char[]","name":"key","decl":"const char[] key"}]},{"name":"GetKeyValue","docStart":3402,"docEnd":3706,"docs":{"brief":"Gets the value of a key from the \"Keys\" section.","tags":[{"tag":"","text":"Gets the value of a key from the \"Keys\" section."},{"tag":"param:key","text":"Gets the value of a key from the \"Keys\" section. \n Key to retrieve from the Keys section."},{"tag":"param:buffer","text":"Gets the value of a key from the \"Keys\" section. \n Key to retrieve from the Keys section. Destination string buffer."},{"tag":"param:maxlen","text":"Gets the value of a key from the \"Keys\" section. \n Key to retrieve from the Keys section. Destination string buffer. Maximum length of output string buffer."},{"tag":"return","text":"Gets the value of a key from the \"Keys\" section. \n Key to retrieve from the Keys section. Destination string buffer. Maximum length of output string buffer. True if key existed, false otherwise"}]},"kind":null,"returnType":"bool","arguments":[{"type":"const char[]","name":"key","decl":"const char[] key"},{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlen","decl":"int maxlen"}]},{"name":"GetAddress","docStart":3790,"docEnd":4065,"docs":{"brief":"Finds an address calculation in a GameConfig file, performs LoadFromAddress on it as appropriate, then returns the final address.","tags":[{"tag":"","text":"Finds an address calculation in a GameConfig file, performs LoadFromAddress on it as appropriate, then returns the final address."},{"tag":"param:name","text":"Finds an address calculation in a GameConfig file, performs LoadFromAddress on it as appropriate, then returns the final address. \n Name of the property to find."},{"tag":"return","text":"Finds an address calculation in a GameConfig file, performs LoadFromAddress on it as appropriate, then returns the final address. \n Name of the property to find. An address calculated on success, or 0 on failure"}]},"kind":null,"returnType":"Address","arguments":[{"type":"const char[]","name":"name","decl":"const char[] name"}]}],"properties":[]},{"name":"FrameIterator","docStart":0,"docEnd":0,"docs":null,"methods":[{"name":"FrameIterator","docStart":26365,"docEnd":26487,"docs":{"brief":"Creates a stack frame iterator to build your own stack traces.","tags":[{"tag":"","text":"Creates a stack frame iterator to build your own stack traces."},{"tag":"return","text":"Creates a stack frame iterator to build your own stack traces. New handle to a FrameIterator"}]},"kind":null,"returnType":"FrameIterator","arguments":[]},{"name":"Next","docStart":26525,"docEnd":26722,"docs":{"brief":"Advances the iterator to the next stack frame.","tags":[{"tag":"","text":"Advances the iterator to the next stack frame."},{"tag":"return","text":"Advances the iterator to the next stack frame. True if another frame was fetched and data can be successfully read."},{"tag":"error","text":"Advances the iterator to the next stack frame. True if another frame was fetched and data can be successfully read. No next element exception"}]},"kind":null,"returnType":"bool","arguments":[]},{"name":"Reset","docStart":26756,"docEnd":26810,"docs":{"brief":"Resets the iterator back to it's starting position","tags":[{"tag":"","text":"Resets the iterator back to it's starting position"}]},"kind":null,"returnType":"void","arguments":[]},{"name":"GetFunctionName","docStart":26962,"docEnd":27107,"docs":{"brief":"Gets the name of the current function in the call stack.","tags":[{"tag":"","text":"Gets the name of the current function in the call stack."},{"tag":"param:buffer","text":"Gets the name of the current function in the call stack. \n Buffer to copy to."},{"tag":"param:maxlen","text":"Gets the name of the current function in the call stack. \n Buffer to copy to. Max size of the buffer"}]},"kind":null,"returnType":"void","arguments":[{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlen","decl":"int maxlen"}]},{"name":"GetFilePath","docStart":27177,"docEnd":27323,"docs":{"brief":"Gets the file path to the current call in the call stack.","tags":[{"tag":"","text":"Gets the file path to the current call in the call stack."},{"tag":"param:buffer","text":"Gets the file path to the current call in the call stack. \n Buffer to copy to."},{"tag":"param:maxlen","text":"Gets the file path to the current call in the call stack. \n Buffer to copy to. Max size of the buffer"}]},"kind":null,"returnType":"void","arguments":[{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlen","decl":"int maxlen"}]}],"properties":[{"name":"LineNumber","docStart":26845,"docEnd":26901,"docs":{"brief":"Returns the line number of the current function call","tags":[{"tag":"","text":"Returns the line number of the current function call"}]},"type":"int","getter":true,"setter":false}]}],"constants":[],"enums":[{"name":"APLRes","docStart":0,"docEnd":0,"docs":null,"entries":[{"name":"APLRes_Success","docStart":2627,"docEnd":2653,"docs":null},{"name":"APLRes_Failure","docStart":2680,"docEnd":2737,"docs":null},{"name":"APLRes_SilentFailure","docStart":2764,"docEnd":2812,"docs":null}]},{"name":"FeatureType","docStart":23507,"docEnd":23534,"docs":{"brief":"Feature types.","tags":[{"tag":"","text":"Feature types."}]},"entries":[{"name":"FeatureType_Native","docStart":23558,"docEnd":23596,"docs":null},{"name":"FeatureType_Capability","docStart":23623,"docEnd":23971,"docs":null}]},{"name":"FeatureStatus","docStart":24004,"docEnd":24034,"docs":{"brief":"Feature statuses.","tags":[{"tag":"","text":"Feature statuses."}]},"entries":[{"name":"FeatureStatus_Available","docStart":24060,"docEnd":24104,"docs":null},{"name":"FeatureStatus_Unavailable","docStart":24136,"docEnd":24176,"docs":null},{"name":"FeatureStatus_Unknown","docStart":24210,"docEnd":24253,"docs":null}]},{"name":"NumberType","docStart":25436,"docEnd":25516,"docs":{"brief":"Represents how many bytes we can read from an address with one load","tags":[{"tag":"","text":"Represents how many bytes we can read from an address with one load"}]},"entries":[{"name":"NumberType_Int8","docStart":0,"docEnd":0,"docs":null},{"name":"NumberType_Int16","docStart":0,"docEnd":0,"docs":null},{"name":"NumberType_Int32","docStart":0,"docEnd":0,"docs":null}]},{"name":"Address","docStart":0,"docEnd":0,"docs":null,"entries":[{"name":"Address_Null","docStart":25663,"docEnd":25719,"docs":null}]}],"typesets":[],"typedefs":[]}