{"functions":[{"name":"OnPluginStart","docStart":4128,"docEnd":4433,"docs":{"brief":"Called when the plugin is fully initialized and all known external referencesare resolved. This is only called once in the lifetime of the plugin, and ispaired with OnPluginEnd().\nIf any run-time error is thrown during this callback, the plugin will be markedas failed.","tags":[{"tag":"","text":"Called when the plugin is fully initialized and all known external referencesare resolved. This is only called once in the lifetime of the plugin, and ispaired with OnPluginEnd().\nIf any run-time error is thrown during this callback, the plugin will be markedas failed."}]},"kind":"forward","returnType":"void","arguments":[]},{"name":"AskPluginLoad","docStart":0,"docEnd":0,"docs":null,"kind":"forward","returnType":"bool","arguments":[{"type":"Handle","name":"myself","decl":"Handle myself"},{"type":"bool","name":"late","decl":"bool late"},{"type":"char[]","name":"error","decl":"char[] error"},{"type":"int","name":"err_max","decl":"int err_max"}]},{"name":"AskPluginLoad2","docStart":4813,"docEnd":5953,"docs":{"brief":"Called before OnPluginStart, in case the plugin wants to check for load failure.This is called even if the plugin type is \"private.\"  Any natives from modules arenot available at this point.  Thus, this forward should only be used for explicitpre-emptive things, such as adding dynamic natives, setting certain types of loadfilters (such as not loading the plugin for certain games).","tags":[{"tag":"","text":"Called before OnPluginStart, in case the plugin wants to check for load failure.This is called even if the plugin type is \"private.\"  Any natives from modules arenot available at this point.  Thus, this forward should only be used for explicitpre-emptive things, such as adding dynamic natives, setting certain types of loadfilters (such as not loading the plugin for certain games)."},{"tag":"note","text":"Called before OnPluginStart, in case the plugin wants to check for load failure.This is called even if the plugin type is \"private.\"  Any natives from modules arenot available at this point.  Thus, this forward should only be used for explicitpre-emptive things, such as adding dynamic natives, setting certain types of loadfilters (such as not loading the plugin for certain games).\nIt is not safe to call externally resolved natives until OnPluginStart()."},{"tag":"note","text":"Called before OnPluginStart, in case the plugin wants to check for load failure.This is called even if the plugin type is \"private.\"  Any natives from modules arenot available at this point.  Thus, this forward should only be used for explicitpre-emptive things, such as adding dynamic natives, setting certain types of loadfilters (such as not loading the plugin for certain games).\nIt is not safe to call externally resolved natives until OnPluginStart().Any sort of RTE in this function will cause the plugin to fail loading."},{"tag":"note","text":"Called before OnPluginStart, in case the plugin wants to check for load failure.This is called even if the plugin type is \"private.\"  Any natives from modules arenot available at this point.  Thus, this forward should only be used for explicitpre-emptive things, such as adding dynamic natives, setting certain types of loadfilters (such as not loading the plugin for certain games).\nIt is not safe to call externally resolved natives until OnPluginStart().Any sort of RTE in this function will cause the plugin to fail loading.If you do not return anything, it is treated like returning success."},{"tag":"note","text":"Called before OnPluginStart, in case the plugin wants to check for load failure.This is called even if the plugin type is \"private.\"  Any natives from modules arenot available at this point.  Thus, this forward should only be used for explicitpre-emptive things, such as adding dynamic natives, setting certain types of loadfilters (such as not loading the plugin for certain games).\nIt is not safe to call externally resolved natives until OnPluginStart().Any sort of RTE in this function will cause the plugin to fail loading.If you do not return anything, it is treated like returning success.If a plugin has an AskPluginLoad2(), AskPluginLoad() will not be called."},{"tag":"param:myself","text":"Called before OnPluginStart, in case the plugin wants to check for load failure.This is called even if the plugin type is \"private.\"  Any natives from modules arenot available at this point.  Thus, this forward should only be used for explicitpre-emptive things, such as adding dynamic natives, setting certain types of loadfilters (such as not loading the plugin for certain games).\nIt is not safe to call externally resolved natives until OnPluginStart().Any sort of RTE in this function will cause the plugin to fail loading.If you do not return anything, it is treated like returning success.If a plugin has an AskPluginLoad2(), AskPluginLoad() will not be called.\nHandle to the plugin."},{"tag":"param:late","text":"Called before OnPluginStart, in case the plugin wants to check for load failure.This is called even if the plugin type is \"private.\"  Any natives from modules arenot available at this point.  Thus, this forward should only be used for explicitpre-emptive things, such as adding dynamic natives, setting certain types of loadfilters (such as not loading the plugin for certain games).\nIt is not safe to call externally resolved natives until OnPluginStart().Any sort of RTE in this function will cause the plugin to fail loading.If you do not return anything, it is treated like returning success.If a plugin has an AskPluginLoad2(), AskPluginLoad() will not be called.\nHandle to the plugin.Whether or not the plugin was loaded \"late\" (after map load)."},{"tag":"param:error","text":"Called before OnPluginStart, in case the plugin wants to check for load failure.This is called even if the plugin type is \"private.\"  Any natives from modules arenot available at this point.  Thus, this forward should only be used for explicitpre-emptive things, such as adding dynamic natives, setting certain types of loadfilters (such as not loading the plugin for certain games).\nIt is not safe to call externally resolved natives until OnPluginStart().Any sort of RTE in this function will cause the plugin to fail loading.If you do not return anything, it is treated like returning success.If a plugin has an AskPluginLoad2(), AskPluginLoad() will not be called.\nHandle to the plugin.Whether or not the plugin was loaded \"late\" (after map load).Error message buffer in case load failed."},{"tag":"param:err_max","text":"Called before OnPluginStart, in case the plugin wants to check for load failure.This is called even if the plugin type is \"private.\"  Any natives from modules arenot available at this point.  Thus, this forward should only be used for explicitpre-emptive things, such as adding dynamic natives, setting certain types of loadfilters (such as not loading the plugin for certain games).\nIt is not safe to call externally resolved natives until OnPluginStart().Any sort of RTE in this function will cause the plugin to fail loading.If you do not return anything, it is treated like returning success.If a plugin has an AskPluginLoad2(), AskPluginLoad() will not be called.\nHandle to the plugin.Whether or not the plugin was loaded \"late\" (after map load).Error message buffer in case load failed.Maximum number of characters for error message buffer."},{"tag":"return","text":"Called before OnPluginStart, in case the plugin wants to check for load failure.This is called even if the plugin type is \"private.\"  Any natives from modules arenot available at this point.  Thus, this forward should only be used for explicitpre-emptive things, such as adding dynamic natives, setting certain types of loadfilters (such as not loading the plugin for certain games).\nIt is not safe to call externally resolved natives until OnPluginStart().Any sort of RTE in this function will cause the plugin to fail loading.If you do not return anything, it is treated like returning success.If a plugin has an AskPluginLoad2(), AskPluginLoad() will not be called.\nHandle to the plugin.Whether or not the plugin was loaded \"late\" (after map load).Error message buffer in case load failed.Maximum number of characters for error message buffer.APLRes_Success for load success, APLRes_Failure or APLRes_SilentFailure otherwise"}]},"kind":"forward","returnType":"APLRes","arguments":[{"type":"Handle","name":"myself","decl":"Handle myself"},{"type":"bool","name":"late","decl":"bool late"},{"type":"char[]","name":"error","decl":"char[] error"},{"type":"int","name":"err_max","decl":"int err_max"}]},{"name":"OnPluginEnd","docStart":6042,"docEnd":6287,"docs":{"brief":"Called when the plugin is about to be unloaded.\nIt is not necessary to close any handles or remove hooks in this function.SourceMod guarantees that plugin shutdown automatically and correctly releasesall resources.","tags":[{"tag":"","text":"Called when the plugin is about to be unloaded.\nIt is not necessary to close any handles or remove hooks in this function.SourceMod guarantees that plugin shutdown automatically and correctly releasesall resources."}]},"kind":"forward","returnType":"void","arguments":[]},{"name":"OnPluginPauseChange","docStart":6320,"docEnd":6465,"docs":{"brief":"Called when the plugin's pause status is changing.","tags":[{"tag":"","text":"Called when the plugin's pause status is changing."},{"tag":"param:pause","text":"Called when the plugin's pause status is changing.\nTrue if the plugin is being paused, false otherwise."}]},"kind":"forward","returnType":"void","arguments":[{"type":"bool","name":"pause","decl":"bool pause"}]},{"name":"OnGameFrame","docStart":6516,"docEnd":6656,"docs":{"brief":"Called before every server frame.  Note that you should avoiddoing expensive computations or declaring large local arrays.","tags":[{"tag":"","text":"Called before every server frame.  Note that you should avoiddoing expensive computations or declaring large local arrays."}]},"kind":"forward","returnType":"void","arguments":[]},{"name":"OnMapStart","docStart":6689,"docEnd":6860,"docs":{"brief":"Called when the map is loaded.","tags":[{"tag":"","text":"Called when the map is loaded."},{"tag":"note","text":"Called when the map is loaded.\nThis used to be OnServerLoad(), which is now deprecated.Plugins still using the old forward will work."}]},"kind":"forward","returnType":"void","arguments":[]},{"name":"OnMapEnd","docStart":6892,"docEnd":6936,"docs":{"brief":"Called right before a map ends.","tags":[{"tag":"","text":"Called right before a map ends."}]},"kind":"forward","returnType":"void","arguments":[]},{"name":"OnConfigsExecuted","docStart":6966,"docEnd":7310,"docs":{"brief":"Called when the map has loaded, servercfgfile (server.cfg) has beenexecuted, and all plugin configs are done executing.  This is the bestplace to initialize plugin functions which are based on cvar data.","tags":[{"tag":"","text":"Called when the map has loaded, servercfgfile (server.cfg) has beenexecuted, and all plugin configs are done executing.  This is the bestplace to initialize plugin functions which are based on cvar data."},{"tag":"note","text":"Called when the map has loaded, servercfgfile (server.cfg) has beenexecuted, and all plugin configs are done executing.  This is the bestplace to initialize plugin functions which are based on cvar data.\nThis will always be called once and only once per map.  It will becalled after OnMapStart()."}]},"kind":"forward","returnType":"void","arguments":[]},{"name":"OnAutoConfigsBuffered","docStart":7349,"docEnd":7914,"docs":{"brief":"This is called once, right after OnMapStart() but any time beforeOnConfigsExecuted().  It is called after the \"exec sourcemod.cfg\"command and all AutoExecConfig() exec commands have been added tothe ServerCommand() buffer.\nIf you need to load per-map settings that override default values,adding commands to the ServerCommand() buffer here will guaranteethat they're set before OnConfigsExecuted().\nUnlike OnMapStart() and OnConfigsExecuted(), this is not called onlate loads that occur after OnMapStart().","tags":[{"tag":"","text":"This is called once, right after OnMapStart() but any time beforeOnConfigsExecuted().  It is called after the \"exec sourcemod.cfg\"command and all AutoExecConfig() exec commands have been added tothe ServerCommand() buffer.\nIf you need to load per-map settings that override default values,adding commands to the ServerCommand() buffer here will guaranteethat they're set before OnConfigsExecuted().\nUnlike OnMapStart() and OnConfigsExecuted(), this is not called onlate loads that occur after OnMapStart()."}]},"kind":"forward","returnType":"void","arguments":[]},{"name":"OnServerCfg","docStart":0,"docEnd":0,"docs":null,"kind":"forward","returnType":"void","arguments":[]},{"name":"OnAllPluginsLoaded","docStart":8108,"docEnd":8288,"docs":{"brief":"Called after all plugins have been loaded.  This is called once forevery plugin.  If a plugin late loads, it will be called immediatelyafter OnPluginStart().","tags":[{"tag":"","text":"Called after all plugins have been loaded.  This is called once forevery plugin.  If a plugin late loads, it will be called immediatelyafter OnPluginStart()."}]},"kind":"forward","returnType":"void","arguments":[]},{"name":"GetMyHandle","docStart":8328,"docEnd":8436,"docs":{"brief":"Returns the calling plugin's Handle.","tags":[{"tag":"","text":"Returns the calling plugin's Handle."},{"tag":"return","text":"Returns the calling plugin's Handle.\nHandle of the calling plugin."}]},"kind":"native","returnType":"Handle","arguments":[]},{"name":"GetPluginIterator","docStart":8470,"docEnd":8700,"docs":{"brief":"Returns an iterator that can be used to search through plugins.","tags":[{"tag":"","text":"Returns an iterator that can be used to search through plugins."},{"tag":"return","text":"Returns an iterator that can be used to search through plugins.\nHandle to iterate with.  Must be closed viaCloseHandle()."},{"tag":"error","text":"Returns an iterator that can be used to search through plugins.\nHandle to iterate with.  Must be closed viaCloseHandle().Invalid Handle."}]},"kind":"native","returnType":"Handle","arguments":[]},{"name":"MorePlugins","docStart":8740,"docEnd":8983,"docs":{"brief":"Returns whether there are more plugins available in the iterator.","tags":[{"tag":"","text":"Returns whether there are more plugins available in the iterator."},{"tag":"param:iter","text":"Returns whether there are more plugins available in the iterator.\nHandle to the plugin iterator."},{"tag":"return","text":"Returns whether there are more plugins available in the iterator.\nHandle to the plugin iterator.True on more plugins, false otherwise."},{"tag":"error","text":"Returns whether there are more plugins available in the iterator.\nHandle to the plugin iterator.True on more plugins, false otherwise.Invalid Handle."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"iter","decl":"Handle iter"}]},{"name":"ReadPlugin","docStart":9026,"docEnd":9327,"docs":{"brief":"Returns the current plugin in the iterator and advances the iterator.","tags":[{"tag":"","text":"Returns the current plugin in the iterator and advances the iterator."},{"tag":"param:iter","text":"Returns the current plugin in the iterator and advances the iterator.\nHandle to the plugin iterator."},{"tag":"return","text":"Returns the current plugin in the iterator and advances the iterator.\nHandle to the plugin iterator.Current plugin the iterator is at, beforethe iterator is advanced."},{"tag":"error","text":"Returns the current plugin in the iterator and advances the iterator.\nHandle to the plugin iterator.Current plugin the iterator is at, beforethe iterator is advanced.Invalid Handle."}]},"kind":"native","returnType":"Handle","arguments":[{"type":"Handle","name":"iter","decl":"Handle iter"}]},{"name":"GetPluginStatus","docStart":9371,"docEnd":9589,"docs":{"brief":"Returns a plugin's status.","tags":[{"tag":"","text":"Returns a plugin's status."},{"tag":"param:plugin","text":"Returns a plugin's status.\nPlugin Handle (INVALID_HANDLE uses the calling plugin)."},{"tag":"return","text":"Returns a plugin's status.\nPlugin Handle (INVALID_HANDLE uses the calling plugin).Status code for the plugin."},{"tag":"error","text":"Returns a plugin's status.\nPlugin Handle (INVALID_HANDLE uses the calling plugin).Status code for the plugin.Invalid Handle."}]},"kind":"native","returnType":"PluginStatus","arguments":[{"type":"Handle","name":"plugin","decl":"Handle plugin"}]},{"name":"GetPluginFilename","docStart":9646,"docEnd":9967,"docs":{"brief":"Retrieves a plugin's file name relative to the plugins folder.","tags":[{"tag":"","text":"Retrieves a plugin's file name relative to the plugins folder."},{"tag":"param:plugin","text":"Retrieves a plugin's file name relative to the plugins folder.\nPlugin Handle (INVALID_HANDLE uses the calling plugin)."},{"tag":"param:buffer","text":"Retrieves a plugin's file name relative to the plugins folder.\nPlugin Handle (INVALID_HANDLE uses the calling plugin).Buffer to the store the file name."},{"tag":"param:maxlength","text":"Retrieves a plugin's file name relative to the plugins folder.\nPlugin Handle (INVALID_HANDLE uses the calling plugin).Buffer to the store the file name.Maximum length of the name buffer."},{"tag":"error","text":"Retrieves a plugin's file name relative to the plugins folder.\nPlugin Handle (INVALID_HANDLE uses the calling plugin).Buffer to the store the file name.Maximum length of the name buffer.Invalid Handle."}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"plugin","decl":"Handle plugin"},{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlength","decl":"int maxlength"}]},{"name":"IsPluginDebugging","docStart":10048,"docEnd":10305,"docs":{"brief":"Retrieves whether or not a plugin is being debugged.","tags":[{"tag":"","text":"Retrieves whether or not a plugin is being debugged."},{"tag":"param:plugin","text":"Retrieves whether or not a plugin is being debugged.\nPlugin Handle (INVALID_HANDLE uses the calling plugin)."},{"tag":"return","text":"Retrieves whether or not a plugin is being debugged.\nPlugin Handle (INVALID_HANDLE uses the calling plugin).True if being debugged, false otherwise."},{"tag":"error","text":"Retrieves whether or not a plugin is being debugged.\nPlugin Handle (INVALID_HANDLE uses the calling plugin).True if being debugged, false otherwise.Invalid Handle."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"plugin","decl":"Handle plugin"}]},{"name":"GetPluginInfo","docStart":10356,"docEnd":10766,"docs":{"brief":"Retrieves a plugin's public info.","tags":[{"tag":"","text":"Retrieves a plugin's public info."},{"tag":"param:plugin","text":"Retrieves a plugin's public info.\nPlugin Handle (INVALID_HANDLE uses the calling plugin)."},{"tag":"param:info","text":"Retrieves a plugin's public info.\nPlugin Handle (INVALID_HANDLE uses the calling plugin).Plugin info property to retrieve."},{"tag":"param:buffer","text":"Retrieves a plugin's public info.\nPlugin Handle (INVALID_HANDLE uses the calling plugin).Plugin info property to retrieve.Buffer to store info in."},{"tag":"param:maxlength","text":"Retrieves a plugin's public info.\nPlugin Handle (INVALID_HANDLE uses the calling plugin).Plugin info property to retrieve.Buffer to store info in.Maximum length of buffer."},{"tag":"return","text":"Retrieves a plugin's public info.\nPlugin Handle (INVALID_HANDLE uses the calling plugin).Plugin info property to retrieve.Buffer to store info in.Maximum length of buffer.True on success, false if property is not available."},{"tag":"error","text":"Retrieves a plugin's public info.\nPlugin Handle (INVALID_HANDLE uses the calling plugin).Plugin info property to retrieve.Buffer to store info in.Maximum length of buffer.True on success, false if property is not available.Invalid Handle."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"plugin","decl":"Handle plugin"},{"type":"PluginInfo","name":"info","decl":"PluginInfo info"},{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlength","decl":"int maxlength"}]},{"name":"FindPluginByNumber","docStart":10860,"docEnd":11368,"docs":{"brief":"Finds a plugin by its order in the list from the \"plugins list\" server\"sm\" command.  You should not use this function to loop through all plugins,use the iterator instead.  Looping through all plugins using this nativeis O(n^2), whereas using the iterator is O(n).","tags":[{"tag":"","text":"Finds a plugin by its order in the list from the \"plugins list\" server\"sm\" command.  You should not use this function to loop through all plugins,use the iterator instead.  Looping through all plugins using this nativeis O(n^2), whereas using the iterator is O(n)."},{"tag":"param:order_num","text":"Finds a plugin by its order in the list from the \"plugins list\" server\"sm\" command.  You should not use this function to loop through all plugins,use the iterator instead.  Looping through all plugins using this nativeis O(n^2), whereas using the iterator is O(n).\nNumber of the plugin as it appears in \"sm plugins list\"."},{"tag":"return","text":"Finds a plugin by its order in the list from the \"plugins list\" server\"sm\" command.  You should not use this function to loop through all plugins,use the iterator instead.  Looping through all plugins using this nativeis O(n^2), whereas using the iterator is O(n).\nNumber of the plugin as it appears in \"sm plugins list\".Plugin Handle on success, INVALID_HANDLE if no pluginmatches the given number."}]},"kind":"native","returnType":"Handle","arguments":[{"type":"int","name":"order_num","decl":"int order_num"}]},{"name":"SetFailState","docStart":11422,"docEnd":12145,"docs":{"brief":"Causes the plugin to enter a failed state.  An error will be thrown andthe plugin will be paused until it is unloaded or reloaded.\nFor backwards compatibility, if no extra arguments are passed, noformatting is applied.  If one or more additional arguments is passed,the string is formatted using Format().  If any errors are encounteredduring formatting, both the format specifier string and an additionalerror message are written.\nThis function does not return, and no further code in the plugin isexecuted.","tags":[{"tag":"","text":"Causes the plugin to enter a failed state.  An error will be thrown andthe plugin will be paused until it is unloaded or reloaded.\nFor backwards compatibility, if no extra arguments are passed, noformatting is applied.  If one or more additional arguments is passed,the string is formatted using Format().  If any errors are encounteredduring formatting, both the format specifier string and an additionalerror message are written.\nThis function does not return, and no further code in the plugin isexecuted."},{"tag":"param:string","text":"Causes the plugin to enter a failed state.  An error will be thrown andthe plugin will be paused until it is unloaded or reloaded.\nFor backwards compatibility, if no extra arguments are passed, noformatting is applied.  If one or more additional arguments is passed,the string is formatted using Format().  If any errors are encounteredduring formatting, both the format specifier string and an additionalerror message are written.\nThis function does not return, and no further code in the plugin isexecuted.\nFormat specifier string."},{"tag":"param:...","text":"Causes the plugin to enter a failed state.  An error will be thrown andthe plugin will be paused until it is unloaded or reloaded.\nFor backwards compatibility, if no extra arguments are passed, noformatting is applied.  If one or more additional arguments is passed,the string is formatted using Format().  If any errors are encounteredduring formatting, both the format specifier string and an additionalerror message are written.\nThis function does not return, and no further code in the plugin isexecuted.\nFormat specifier string.Formatting arguments."},{"tag":"error","text":"Causes the plugin to enter a failed state.  An error will be thrown andthe plugin will be paused until it is unloaded or reloaded.\nFor backwards compatibility, if no extra arguments are passed, noformatting is applied.  If one or more additional arguments is passed,the string is formatted using Format().  If any errors are encounteredduring formatting, both the format specifier string and an additionalerror message are written.\nThis function does not return, and no further code in the plugin isexecuted.\nFormat specifier string.Formatting arguments.Always throws SP_ERROR_ABORT."}]},"kind":"native","returnType":"void","arguments":[{"type":"const char[]","name":"string","decl":"const char[] string"},{"type":"any...","name":"...","decl":"any... ..."}]},{"name":"ThrowError","docStart":12206,"docEnd":12464,"docs":{"brief":"Aborts the current callback and throws an error.  This functiondoes not return in that no code is executed following it.","tags":[{"tag":"","text":"Aborts the current callback and throws an error.  This functiondoes not return in that no code is executed following it."},{"tag":"param:fmt","text":"Aborts the current callback and throws an error.  This functiondoes not return in that no code is executed following it.\nString format."},{"tag":"param:...","text":"Aborts the current callback and throws an error.  This functiondoes not return in that no code is executed following it.\nString format.Format arguments."},{"tag":"error","text":"Aborts the current callback and throws an error.  This functiondoes not return in that no code is executed following it.\nString format.Format arguments.Always!"}]},"kind":"native","returnType":"void","arguments":[{"type":"const char[]","name":"fmt","decl":"const char[] fmt"},{"type":"any...","name":"...","decl":"any... ..."}]},{"name":"LogStackTrace","docStart":12520,"docEnd":12795,"docs":{"brief":"Logs a stack trace from the current function call. Codeexecution continues after the call","tags":[{"tag":"","text":"Logs a stack trace from the current function call. Codeexecution continues after the call"},{"tag":"param:fmt","text":"Logs a stack trace from the current function call. Codeexecution continues after the call\nFormat string to send with the stack trace."},{"tag":"param:...","text":"Logs a stack trace from the current function call. Codeexecution continues after the call\nFormat string to send with the stack trace.Format arguments."},{"tag":"error","text":"Logs a stack trace from the current function call. Codeexecution continues after the call\nFormat string to send with the stack trace.Format arguments.Always logs a stack trace."}]},"kind":"native","returnType":"void","arguments":[{"type":"const char[]","name":"fmt","decl":"const char[] fmt"},{"type":"any...","name":"...","decl":"any... ..."}]},{"name":"GetTime","docStart":12854,"docEnd":13064,"docs":{"brief":"Gets the system time as a unix timestamp.","tags":[{"tag":"","text":"Gets the system time as a unix timestamp."},{"tag":"param:bigStamp","text":"Gets the system time as a unix timestamp.\nOptional array to store the 64bit timestamp in."},{"tag":"return","text":"Gets the system time as a unix timestamp.\nOptional array to store the 64bit timestamp in.32bit timestamp (number of seconds since unix epoch)."}]},"kind":"native","returnType":"int","arguments":[{"type":"int[2]","name":"bigStamp","decl":"int bigStamp[2]"}]},{"name":"FormatTime","docStart":13112,"docEnd":13868,"docs":{"brief":"Produces a date and/or time string value for a timestamp.\nSee this URL for valid parameters:http://cplusplus.com/reference/clibrary/ctime/strftime.html\nNote that available parameters depends on support from your operating system.In particular, ones highlighted in yellow on that page are not currentlyavailable on Windows and should be avoided for portable plugins.","tags":[{"tag":"","text":"Produces a date and/or time string value for a timestamp.\nSee this URL for valid parameters:http://cplusplus.com/reference/clibrary/ctime/strftime.html\nNote that available parameters depends on support from your operating system.In particular, ones highlighted in yellow on that page are not currentlyavailable on Windows and should be avoided for portable plugins."},{"tag":"param:buffer","text":"Produces a date and/or time string value for a timestamp.\nSee this URL for valid parameters:http://cplusplus.com/reference/clibrary/ctime/strftime.html\nNote that available parameters depends on support from your operating system.In particular, ones highlighted in yellow on that page are not currentlyavailable on Windows and should be avoided for portable plugins.\nDestination string buffer."},{"tag":"param:maxlength","text":"Produces a date and/or time string value for a timestamp.\nSee this URL for valid parameters:http://cplusplus.com/reference/clibrary/ctime/strftime.html\nNote that available parameters depends on support from your operating system.In particular, ones highlighted in yellow on that page are not currentlyavailable on Windows and should be avoided for portable plugins.\nDestination string buffer.Maximum length of output string buffer."},{"tag":"param:format","text":"Produces a date and/or time string value for a timestamp.\nSee this URL for valid parameters:http://cplusplus.com/reference/clibrary/ctime/strftime.html\nNote that available parameters depends on support from your operating system.In particular, ones highlighted in yellow on that page are not currentlyavailable on Windows and should be avoided for portable plugins.\nDestination string buffer.Maximum length of output string buffer.Formatting rules (passing NULL_STRING will use the rules defined in sm_datetime_format)."},{"tag":"param:stamp","text":"Produces a date and/or time string value for a timestamp.\nSee this URL for valid parameters:http://cplusplus.com/reference/clibrary/ctime/strftime.html\nNote that available parameters depends on support from your operating system.In particular, ones highlighted in yellow on that page are not currentlyavailable on Windows and should be avoided for portable plugins.\nDestination string buffer.Maximum length of output string buffer.Formatting rules (passing NULL_STRING will use the rules defined in sm_datetime_format).Optional time stamp."},{"tag":"error","text":"Produces a date and/or time string value for a timestamp.\nSee this URL for valid parameters:http://cplusplus.com/reference/clibrary/ctime/strftime.html\nNote that available parameters depends on support from your operating system.In particular, ones highlighted in yellow on that page are not currentlyavailable on Windows and should be avoided for portable plugins.\nDestination string buffer.Maximum length of output string buffer.Formatting rules (passing NULL_STRING will use the rules defined in sm_datetime_format).Optional time stamp.Buffer too small or invalid time format."}]},"kind":"native","returnType":"void","arguments":[{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlength","decl":"int maxlength"},{"type":"const char[]","name":"format","decl":"const char[] format"},{"type":"int","name":"stamp","decl":"int stamp"}]},{"name":"LoadGameConfigFile","docStart":13962,"docEnd":14269,"docs":{"brief":"Loads a game config file.","tags":[{"tag":"","text":"Loads a game config file."},{"tag":"param:file","text":"Loads a game config file.\nFile to load.  The path must be relative to the 'gamedata' folder under the config folderand the extension should be omitted."},{"tag":"return","text":"Loads a game config file.\nFile to load.  The path must be relative to the 'gamedata' folder under the config folderand the extension should be omitted.A handle to the game config file or INVALID_HANDLE on failure."}]},"kind":"native","returnType":"GameData","arguments":[{"type":"const char[]","name":"file","decl":"const char[] file"}]},{"name":"GameConfGetOffset","docStart":14329,"docEnd":14535,"docs":{"brief":"Returns an offset value.","tags":[{"tag":"","text":"Returns an offset value."},{"tag":"param:gc","text":"Returns an offset value.\nGame config handle."},{"tag":"param:key","text":"Returns an offset value.\nGame config handle.Key to retrieve from the offset section."},{"tag":"return","text":"Returns an offset value.\nGame config handle.Key to retrieve from the offset section.An offset, or -1 on failure."}]},"kind":"native","returnType":"int","arguments":[{"type":"Handle","name":"gc","decl":"Handle gc"},{"type":"const char[]","name":"key","decl":"const char[] key"}]},{"name":"GameConfGetKeyValue","docStart":14599,"docEnd":14953,"docs":{"brief":"Gets the value of a key from the \"Keys\" section.","tags":[{"tag":"","text":"Gets the value of a key from the \"Keys\" section."},{"tag":"param:gc","text":"Gets the value of a key from the \"Keys\" section.\nGame config handle."},{"tag":"param:key","text":"Gets the value of a key from the \"Keys\" section.\nGame config handle.Key to retrieve from the Keys section."},{"tag":"param:buffer","text":"Gets the value of a key from the \"Keys\" section.\nGame config handle.Key to retrieve from the Keys section.Destination string buffer."},{"tag":"param:maxlen","text":"Gets the value of a key from the \"Keys\" section.\nGame config handle.Key to retrieve from the Keys section.Destination string buffer.Maximum length of output string buffer."},{"tag":"return","text":"Gets the value of a key from the \"Keys\" section.\nGame config handle.Key to retrieve from the Keys section.Destination string buffer.Maximum length of output string buffer.True if key existed, false otherwise."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"gc","decl":"Handle gc"},{"type":"const char[]","name":"key","decl":"const char[] key"},{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlen","decl":"int maxlen"}]},{"name":"GameConfGetAddress","docStart":15047,"docEnd":15373,"docs":{"brief":"Finds an address calculation in a GameConfig file,performs LoadFromAddress on it as appropriate, then returns the final address.","tags":[{"tag":"","text":"Finds an address calculation in a GameConfig file,performs LoadFromAddress on it as appropriate, then returns the final address."},{"tag":"param:gameconf","text":"Finds an address calculation in a GameConfig file,performs LoadFromAddress on it as appropriate, then returns the final address.\nGame config handle."},{"tag":"param:name","text":"Finds an address calculation in a GameConfig file,performs LoadFromAddress on it as appropriate, then returns the final address.\nGame config handle.Name of the property to find."},{"tag":"return","text":"Finds an address calculation in a GameConfig file,performs LoadFromAddress on it as appropriate, then returns the final address.\nGame config handle.Name of the property to find.An address calculated on success, or 0 on failure."}]},"kind":"native","returnType":"Address","arguments":[{"type":"Handle","name":"gameconf","decl":"Handle gameconf"},{"type":"const char[]","name":"name","decl":"const char[] name"}]},{"name":"GetSysTickCount","docStart":15449,"docEnd":15680,"docs":{"brief":"Returns the operating system's \"tick count,\" which is a number ofmilliseconds since the operating system loaded.  This can be usedfor basic benchmarks.","tags":[{"tag":"","text":"Returns the operating system's \"tick count,\" which is a number ofmilliseconds since the operating system loaded.  This can be usedfor basic benchmarks."},{"tag":"return","text":"Returns the operating system's \"tick count,\" which is a number ofmilliseconds since the operating system loaded.  This can be usedfor basic benchmarks.\nTick count in milliseconds."}]},"kind":"native","returnType":"int","arguments":[]},{"name":"AutoExecConfig","docStart":15715,"docEnd":16404,"docs":{"brief":"Specifies that the given config file should be executed after plugin load.OnConfigsExecuted() will not be called until the config file has executed,but it will be called if the execution fails.","tags":[{"tag":"","text":"Specifies that the given config file should be executed after plugin load.OnConfigsExecuted() will not be called until the config file has executed,but it will be called if the execution fails."},{"tag":"param:autoCreate","text":"Specifies that the given config file should be executed after plugin load.OnConfigsExecuted() will not be called until the config file has executed,but it will be called if the execution fails.\nIf true, and the config file does not exist, such a configfile will be automatically created and populated withinformation from the plugin's registered cvars."},{"tag":"param:name","text":"Specifies that the given config file should be executed after plugin load.OnConfigsExecuted() will not be called until the config file has executed,but it will be called if the execution fails.\nIf true, and the config file does not exist, such a configfile will be automatically created and populated withinformation from the plugin's registered cvars.Name of the config file, excluding the .cfg extension.If empty, <plugin.filename.cfg> is assumed."},{"tag":"param:folder","text":"Specifies that the given config file should be executed after plugin load.OnConfigsExecuted() will not be called until the config file has executed,but it will be called if the execution fails.\nIf true, and the config file does not exist, such a configfile will be automatically created and populated withinformation from the plugin's registered cvars.Name of the config file, excluding the .cfg extension.If empty, <plugin.filename.cfg> is assumed.Folder under cfg/ to use.  By default this is \"sourcemod.\""}]},"kind":"native","returnType":"void","arguments":[{"type":"bool","name":"autoCreate","decl":"bool autoCreate"},{"type":"const char[]","name":"name","decl":"const char[] name"},{"type":"const char[]","name":"folder","decl":"const char[] folder"}]},{"name":"RegPluginLibrary","docStart":16514,"docEnd":16648,"docs":{"brief":"Registers a library name for identifying as a dependency toother plugins.","tags":[{"tag":"","text":"Registers a library name for identifying as a dependency toother plugins."},{"tag":"param:name","text":"Registers a library name for identifying as a dependency toother plugins.\nLibrary name."}]},"kind":"native","returnType":"void","arguments":[{"type":"const char[]","name":"name","decl":"const char[] name"}]},{"name":"LibraryExists","docStart":16702,"docEnd":17090,"docs":{"brief":"Returns whether a library exists.  This function should be consideredexpensive; it should only be called on plugin to determine availabilityof resources.  Use OnLibraryAdded()/OnLibraryRemoved() to detect changesin optional resources.","tags":[{"tag":"","text":"Returns whether a library exists.  This function should be consideredexpensive; it should only be called on plugin to determine availabilityof resources.  Use OnLibraryAdded()/OnLibraryRemoved() to detect changesin optional resources."},{"tag":"param:name","text":"Returns whether a library exists.  This function should be consideredexpensive; it should only be called on plugin to determine availabilityof resources.  Use OnLibraryAdded()/OnLibraryRemoved() to detect changesin optional resources.\nLibrary name of a plugin or extension."},{"tag":"return","text":"Returns whether a library exists.  This function should be consideredexpensive; it should only be called on plugin to determine availabilityof resources.  Use OnLibraryAdded()/OnLibraryRemoved() to detect changesin optional resources.\nLibrary name of a plugin or extension.True if exists, false otherwise."}]},"kind":"native","returnType":"bool","arguments":[{"type":"const char[]","name":"name","decl":"const char[] name"}]},{"name":"GetExtensionFileStatus","docStart":17141,"docEnd":17670,"docs":{"brief":"Returns the status of an extension, by filename.","tags":[{"tag":"","text":"Returns the status of an extension, by filename."},{"tag":"param:name","text":"Returns the status of an extension, by filename.\nExtension name (like \"sdktools.ext\")."},{"tag":"param:error","text":"Returns the status of an extension, by filename.\nExtension name (like \"sdktools.ext\").Optional error message buffer."},{"tag":"param:maxlength","text":"Returns the status of an extension, by filename.\nExtension name (like \"sdktools.ext\").Optional error message buffer.Length of optional error message buffer."},{"tag":"return","text":"Returns the status of an extension, by filename.\nExtension name (like \"sdktools.ext\").Optional error message buffer.Length of optional error message buffer.-2 if the extension was not found.-1 if the extension was found but failed to load.0 if the extension loaded but reported an error.1 if the extension is running without error."}]},"kind":"native","returnType":"int","arguments":[{"type":"const char[]","name":"name","decl":"const char[] name"},{"type":"char[]","name":"error","decl":"char[] error"},{"type":"int","name":"maxlength","decl":"int maxlength"}]},{"name":"OnLibraryAdded","docStart":17763,"docEnd":17991,"docs":{"brief":"Called after a library is added that the current plugin referencesoptionally. A library is either a plugin name or extension name, asexposed via its include file.","tags":[{"tag":"","text":"Called after a library is added that the current plugin referencesoptionally. A library is either a plugin name or extension name, asexposed via its include file."},{"tag":"param:name","text":"Called after a library is added that the current plugin referencesoptionally. A library is either a plugin name or extension name, asexposed via its include file.\nLibrary name."}]},"kind":"forward","returnType":"void","arguments":[{"type":"const char[]","name":"name","decl":"const char[] name"}]},{"name":"OnLibraryRemoved","docStart":18044,"docEnd":18282,"docs":{"brief":"Called right before a library is removed that the current plugin referencesoptionally.  A library is either a plugin name or extension name, asexposed via its include file.","tags":[{"tag":"","text":"Called right before a library is removed that the current plugin referencesoptionally.  A library is either a plugin name or extension name, asexposed via its include file."},{"tag":"param:name","text":"Called right before a library is removed that the current plugin referencesoptionally.  A library is either a plugin name or extension name, asexposed via its include file.\nLibrary name."}]},"kind":"forward","returnType":"void","arguments":[{"type":"const char[]","name":"name","decl":"const char[] name"}]},{"name":"ReadMapList","docStart":18654,"docEnd":21817,"docs":{"brief":"Loads a map list to an ADT Array.\nA map list is a list of maps from a file.  SourceMod allows easy configuration ofmaplists through addons/sourcemod/configs/maplists.cfg.  Each entry is given aname and a file (for example, \"rtv\" => \"rtv.cfg\"), or a name and a redirection(for example, \"rtv\" => \"default\").  This native will read a map list entry,cache the file, and return the list of maps it holds.\nSerial change numbers are used to identify if a map list has changed.  Thus, ifyou pass a serial change number and it's equal to what SourceMod currently knowsabout the map list, then SourceMod won't re-parse the file.\nIf the maps end up being read from the maps folder (MAPLIST_FLAG_MAPSFOLDER), theyare automatically sorted in alphabetical, ascending order.\nArrays created by this function are temporary and must be freed via CloseHandle().Modifying arrays created by this function will not affect future return values oror the contents of arrays returned to other plugins.","tags":[{"tag":"","text":"Loads a map list to an ADT Array.\nA map list is a list of maps from a file.  SourceMod allows easy configuration ofmaplists through addons/sourcemod/configs/maplists.cfg.  Each entry is given aname and a file (for example, \"rtv\" => \"rtv.cfg\"), or a name and a redirection(for example, \"rtv\" => \"default\").  This native will read a map list entry,cache the file, and return the list of maps it holds.\nSerial change numbers are used to identify if a map list has changed.  Thus, ifyou pass a serial change number and it's equal to what SourceMod currently knowsabout the map list, then SourceMod won't re-parse the file.\nIf the maps end up being read from the maps folder (MAPLIST_FLAG_MAPSFOLDER), theyare automatically sorted in alphabetical, ascending order.\nArrays created by this function are temporary and must be freed via CloseHandle().Modifying arrays created by this function will not affect future return values oror the contents of arrays returned to other plugins."},{"tag":"param:array","text":"Loads a map list to an ADT Array.\nA map list is a list of maps from a file.  SourceMod allows easy configuration ofmaplists through addons/sourcemod/configs/maplists.cfg.  Each entry is given aname and a file (for example, \"rtv\" => \"rtv.cfg\"), or a name and a redirection(for example, \"rtv\" => \"default\").  This native will read a map list entry,cache the file, and return the list of maps it holds.\nSerial change numbers are used to identify if a map list has changed.  Thus, ifyou pass a serial change number and it's equal to what SourceMod currently knowsabout the map list, then SourceMod won't re-parse the file.\nIf the maps end up being read from the maps folder (MAPLIST_FLAG_MAPSFOLDER), theyare automatically sorted in alphabetical, ascending order.\nArrays created by this function are temporary and must be freed via CloseHandle().Modifying arrays created by this function will not affect future return values oror the contents of arrays returned to other plugins.\nArray to store the map list.  If INVALID_HANDLE, a new blankarray will be created.  The blocksize should be at least 16;otherwise results may be truncated.  Items are added to the arrayas strings.  The array is never checked for duplicates, and it isnot read beforehand.  Only the serial number is used to detectchanges."},{"tag":"param:serial","text":"Loads a map list to an ADT Array.\nA map list is a list of maps from a file.  SourceMod allows easy configuration ofmaplists through addons/sourcemod/configs/maplists.cfg.  Each entry is given aname and a file (for example, \"rtv\" => \"rtv.cfg\"), or a name and a redirection(for example, \"rtv\" => \"default\").  This native will read a map list entry,cache the file, and return the list of maps it holds.\nSerial change numbers are used to identify if a map list has changed.  Thus, ifyou pass a serial change number and it's equal to what SourceMod currently knowsabout the map list, then SourceMod won't re-parse the file.\nIf the maps end up being read from the maps folder (MAPLIST_FLAG_MAPSFOLDER), theyare automatically sorted in alphabetical, ascending order.\nArrays created by this function are temporary and must be freed via CloseHandle().Modifying arrays created by this function will not affect future return values oror the contents of arrays returned to other plugins.\nArray to store the map list.  If INVALID_HANDLE, a new blankarray will be created.  The blocksize should be at least 16;otherwise results may be truncated.  Items are added to the arrayas strings.  The array is never checked for duplicates, and it isnot read beforehand.  Only the serial number is used to detectchanges.Serial number to identify last known map list change.  If -1, thethe value will not be checked.  If the map list has since changed,the serial is updated (even if -1 was passed).  If there is an errorfinding a valid maplist, then the serial is set to -1."},{"tag":"param:str","text":"Loads a map list to an ADT Array.\nA map list is a list of maps from a file.  SourceMod allows easy configuration ofmaplists through addons/sourcemod/configs/maplists.cfg.  Each entry is given aname and a file (for example, \"rtv\" => \"rtv.cfg\"), or a name and a redirection(for example, \"rtv\" => \"default\").  This native will read a map list entry,cache the file, and return the list of maps it holds.\nSerial change numbers are used to identify if a map list has changed.  Thus, ifyou pass a serial change number and it's equal to what SourceMod currently knowsabout the map list, then SourceMod won't re-parse the file.\nIf the maps end up being read from the maps folder (MAPLIST_FLAG_MAPSFOLDER), theyare automatically sorted in alphabetical, ascending order.\nArrays created by this function are temporary and must be freed via CloseHandle().Modifying arrays created by this function will not affect future return values oror the contents of arrays returned to other plugins.\nArray to store the map list.  If INVALID_HANDLE, a new blankarray will be created.  The blocksize should be at least 16;otherwise results may be truncated.  Items are added to the arrayas strings.  The array is never checked for duplicates, and it isnot read beforehand.  Only the serial number is used to detectchanges.Serial number to identify last known map list change.  If -1, thethe value will not be checked.  If the map list has since changed,the serial is updated (even if -1 was passed).  If there is an errorfinding a valid maplist, then the serial is set to -1.Config name, or \"default\" for the default map list.  Config namesshould be somewhat descriptive.  For example, the admin menu usesa config name of \"admin menu\".  The list names can be configuredby users in addons/sourcemod/configs/maplists.cfg."},{"tag":"param:flags","text":"Loads a map list to an ADT Array.\nA map list is a list of maps from a file.  SourceMod allows easy configuration ofmaplists through addons/sourcemod/configs/maplists.cfg.  Each entry is given aname and a file (for example, \"rtv\" => \"rtv.cfg\"), or a name and a redirection(for example, \"rtv\" => \"default\").  This native will read a map list entry,cache the file, and return the list of maps it holds.\nSerial change numbers are used to identify if a map list has changed.  Thus, ifyou pass a serial change number and it's equal to what SourceMod currently knowsabout the map list, then SourceMod won't re-parse the file.\nIf the maps end up being read from the maps folder (MAPLIST_FLAG_MAPSFOLDER), theyare automatically sorted in alphabetical, ascending order.\nArrays created by this function are temporary and must be freed via CloseHandle().Modifying arrays created by this function will not affect future return values oror the contents of arrays returned to other plugins.\nArray to store the map list.  If INVALID_HANDLE, a new blankarray will be created.  The blocksize should be at least 16;otherwise results may be truncated.  Items are added to the arrayas strings.  The array is never checked for duplicates, and it isnot read beforehand.  Only the serial number is used to detectchanges.Serial number to identify last known map list change.  If -1, thethe value will not be checked.  If the map list has since changed,the serial is updated (even if -1 was passed).  If there is an errorfinding a valid maplist, then the serial is set to -1.Config name, or \"default\" for the default map list.  Config namesshould be somewhat descriptive.  For example, the admin menu usesa config name of \"admin menu\".  The list names can be configuredby users in addons/sourcemod/configs/maplists.cfg.MAPLIST_FLAG flags."},{"tag":"return","text":"Loads a map list to an ADT Array.\nA map list is a list of maps from a file.  SourceMod allows easy configuration ofmaplists through addons/sourcemod/configs/maplists.cfg.  Each entry is given aname and a file (for example, \"rtv\" => \"rtv.cfg\"), or a name and a redirection(for example, \"rtv\" => \"default\").  This native will read a map list entry,cache the file, and return the list of maps it holds.\nSerial change numbers are used to identify if a map list has changed.  Thus, ifyou pass a serial change number and it's equal to what SourceMod currently knowsabout the map list, then SourceMod won't re-parse the file.\nIf the maps end up being read from the maps folder (MAPLIST_FLAG_MAPSFOLDER), theyare automatically sorted in alphabetical, ascending order.\nArrays created by this function are temporary and must be freed via CloseHandle().Modifying arrays created by this function will not affect future return values oror the contents of arrays returned to other plugins.\nArray to store the map list.  If INVALID_HANDLE, a new blankarray will be created.  The blocksize should be at least 16;otherwise results may be truncated.  Items are added to the arrayas strings.  The array is never checked for duplicates, and it isnot read beforehand.  Only the serial number is used to detectchanges.Serial number to identify last known map list change.  If -1, thethe value will not be checked.  If the map list has since changed,the serial is updated (even if -1 was passed).  If there is an errorfinding a valid maplist, then the serial is set to -1.Config name, or \"default\" for the default map list.  Config namesshould be somewhat descriptive.  For example, the admin menu usesa config name of \"admin menu\".  The list names can be configuredby users in addons/sourcemod/configs/maplists.cfg.MAPLIST_FLAG flags.On failure:INVALID_HANDLE is returned, the serial is set to -1, and the inputarray (if any) is left unchanged.On no change:INVALID_HANDLE is returned, the serial is unchanged, and the inputarray (if any) is left unchanged.On success:A valid array Handle is returned, containing at least one map string.If an array was passed, the return value is equal to the passed ArrayHandle.  If the passed array was not cleared, it will have grown by atleast one item.  The serial number is updated to a positive number."},{"tag":"error","text":"Loads a map list to an ADT Array.\nA map list is a list of maps from a file.  SourceMod allows easy configuration ofmaplists through addons/sourcemod/configs/maplists.cfg.  Each entry is given aname and a file (for example, \"rtv\" => \"rtv.cfg\"), or a name and a redirection(for example, \"rtv\" => \"default\").  This native will read a map list entry,cache the file, and return the list of maps it holds.\nSerial change numbers are used to identify if a map list has changed.  Thus, ifyou pass a serial change number and it's equal to what SourceMod currently knowsabout the map list, then SourceMod won't re-parse the file.\nIf the maps end up being read from the maps folder (MAPLIST_FLAG_MAPSFOLDER), theyare automatically sorted in alphabetical, ascending order.\nArrays created by this function are temporary and must be freed via CloseHandle().Modifying arrays created by this function will not affect future return values oror the contents of arrays returned to other plugins.\nArray to store the map list.  If INVALID_HANDLE, a new blankarray will be created.  The blocksize should be at least 16;otherwise results may be truncated.  Items are added to the arrayas strings.  The array is never checked for duplicates, and it isnot read beforehand.  Only the serial number is used to detectchanges.Serial number to identify last known map list change.  If -1, thethe value will not be checked.  If the map list has since changed,the serial is updated (even if -1 was passed).  If there is an errorfinding a valid maplist, then the serial is set to -1.Config name, or \"default\" for the default map list.  Config namesshould be somewhat descriptive.  For example, the admin menu usesa config name of \"admin menu\".  The list names can be configuredby users in addons/sourcemod/configs/maplists.cfg.MAPLIST_FLAG flags.On failure:INVALID_HANDLE is returned, the serial is set to -1, and the inputarray (if any) is left unchanged.On no change:INVALID_HANDLE is returned, the serial is unchanged, and the inputarray (if any) is left unchanged.On success:A valid array Handle is returned, containing at least one map string.If an array was passed, the return value is equal to the passed ArrayHandle.  If the passed array was not cleared, it will have grown by atleast one item.  The serial number is updated to a positive number.Invalid array Handle that is not INVALID_HANDLE."}]},"kind":"native","returnType":"Handle","arguments":[{"type":"Handle","name":"array","decl":"Handle array"},{"type":"int&","name":"serial","decl":"int& serial"},{"type":"const char[]","name":"str","decl":"const char[] str"},{"type":"int","name":"flags","decl":"int flags"}]},{"name":"SetMapListCompatBind","docStart":22038,"docEnd":22421,"docs":{"brief":"Makes a compatibility binding for map lists.  For example, if a function previously used\"clam.cfg\" for map lists, this function will insert a \"fake\" binding to \"clam.cfg\" thatwill be overridden if it's in the maplists.cfg file.","tags":[{"tag":"","text":"Makes a compatibility binding for map lists.  For example, if a function previously used\"clam.cfg\" for map lists, this function will insert a \"fake\" binding to \"clam.cfg\" thatwill be overridden if it's in the maplists.cfg file."},{"tag":"param:name","text":"Makes a compatibility binding for map lists.  For example, if a function previously used\"clam.cfg\" for map lists, this function will insert a \"fake\" binding to \"clam.cfg\" thatwill be overridden if it's in the maplists.cfg file.\nConfiguration name that would be used with ReadMapList()."},{"tag":"param:file","text":"Makes a compatibility binding for map lists.  For example, if a function previously used\"clam.cfg\" for map lists, this function will insert a \"fake\" binding to \"clam.cfg\" thatwill be overridden if it's in the maplists.cfg file.\nConfiguration name that would be used with ReadMapList().Default file to use."}]},"kind":"native","returnType":"void","arguments":[{"type":"const char[]","name":"name","decl":"const char[] name"},{"type":"const char[]","name":"file","decl":"const char[] file"}]},{"name":"OnClientFloodCheck","docStart":22498,"docEnd":22907,"docs":{"brief":"Called when a client has sent chat text.  This must return either true orfalse to indicate that a client is or is not spamming the server.\nThe return value is a hint only.  Core or another plugin may decideotherwise.","tags":[{"tag":"","text":"Called when a client has sent chat text.  This must return either true orfalse to indicate that a client is or is not spamming the server.\nThe return value is a hint only.  Core or another plugin may decideotherwise."},{"tag":"param:client","text":"Called when a client has sent chat text.  This must return either true orfalse to indicate that a client is or is not spamming the server.\nThe return value is a hint only.  Core or another plugin may decideotherwise.\nClient index.  The server (0) will never be passed."},{"tag":"return","text":"Called when a client has sent chat text.  This must return either true orfalse to indicate that a client is or is not spamming the server.\nThe return value is a hint only.  Core or another plugin may decideotherwise.\nClient index.  The server (0) will never be passed.True if client is spamming the server, false otherwise."}]},"kind":"forward","returnType":"bool","arguments":[{"type":"int","name":"client","decl":"int client"}]},{"name":"OnClientFloodResult","docStart":22957,"docEnd":23442,"docs":{"brief":"Called after a client's flood check has been computed.  This can be usedby antiflood algorithms to decay/increase flooding weights.\nSince the result from \"OnClientFloodCheck\" isn't guaranteed to be thefinal result, it is generally a good idea to use this to play with otheralgorithms nicely.","tags":[{"tag":"","text":"Called after a client's flood check has been computed.  This can be usedby antiflood algorithms to decay/increase flooding weights.\nSince the result from \"OnClientFloodCheck\" isn't guaranteed to be thefinal result, it is generally a good idea to use this to play with otheralgorithms nicely."},{"tag":"param:client","text":"Called after a client's flood check has been computed.  This can be usedby antiflood algorithms to decay/increase flooding weights.\nSince the result from \"OnClientFloodCheck\" isn't guaranteed to be thefinal result, it is generally a good idea to use this to play with otheralgorithms nicely.\nClient index.  The server (0) will never be passed."},{"tag":"param:blocked","text":"Called after a client's flood check has been computed.  This can be usedby antiflood algorithms to decay/increase flooding weights.\nSince the result from \"OnClientFloodCheck\" isn't guaranteed to be thefinal result, it is generally a good idea to use this to play with otheralgorithms nicely.\nClient index.  The server (0) will never be passed.True if client flooded last \"say\", false otherwise."}]},"kind":"forward","returnType":"void","arguments":[{"type":"int","name":"client","decl":"int client"},{"type":"bool","name":"blocked","decl":"bool blocked"}]},{"name":"CanTestFeatures","docStart":24285,"docEnd":24600,"docs":{"brief":"Returns whether \"GetFeatureStatus\" will work. Using this nativeor this function will not cause SourceMod to fail loading on older versions,however, GetFeatureStatus will only work if this function returns true.","tags":[{"tag":"","text":"Returns whether \"GetFeatureStatus\" will work. Using this nativeor this function will not cause SourceMod to fail loading on older versions,however, GetFeatureStatus will only work if this function returns true."},{"tag":"return","text":"Returns whether \"GetFeatureStatus\" will work. Using this nativeor this function will not cause SourceMod to fail loading on older versions,however, GetFeatureStatus will only work if this function returns true.\nTrue if GetFeatureStatus will work, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[]},{"name":"GetFeatureStatus","docStart":24687,"docEnd":24889,"docs":{"brief":"Returns whether a feature exists, and if so, whether it is usable.","tags":[{"tag":"","text":"Returns whether a feature exists, and if so, whether it is usable."},{"tag":"param:type","text":"Returns whether a feature exists, and if so, whether it is usable.\nFeature type."},{"tag":"param:name","text":"Returns whether a feature exists, and if so, whether it is usable.\nFeature type.Feature name."},{"tag":"return","text":"Returns whether a feature exists, and if so, whether it is usable.\nFeature type.Feature name.Feature status."}]},"kind":"native","returnType":"FeatureStatus","arguments":[{"type":"FeatureType","name":"type","decl":"FeatureType type"},{"type":"const char[]","name":"name","decl":"const char[] name"}]},{"name":"RequireFeature","docStart":24970,"docEnd":25308,"docs":{"brief":"Requires that a given feature is available. If it is not, SetFailState()is called with the given message.","tags":[{"tag":"","text":"Requires that a given feature is available. If it is not, SetFailState()is called with the given message."},{"tag":"param:type","text":"Requires that a given feature is available. If it is not, SetFailState()is called with the given message.\nFeature type."},{"tag":"param:name","text":"Requires that a given feature is available. If it is not, SetFailState()is called with the given message.\nFeature type.Feature name."},{"tag":"param:fmt","text":"Requires that a given feature is available. If it is not, SetFailState()is called with the given message.\nFeature type.Feature name.Message format string, or empty to use default."},{"tag":"param:...","text":"Requires that a given feature is available. If it is not, SetFailState()is called with the given message.\nFeature type.Feature name.Message format string, or empty to use default.Message format parameters, if any."}]},"kind":"native","returnType":"void","arguments":[{"type":"FeatureType","name":"type","decl":"FeatureType type"},{"type":"const char[]","name":"name","decl":"const char[] name"},{"type":"const char[]","name":"fmt","decl":"const char[] fmt"},{"type":"any...","name":"...","decl":"any... ..."}]},{"name":"LoadFromAddress","docStart":25727,"docEnd":25963,"docs":{"brief":"Load up to 4 bytes from a memory address.","tags":[{"tag":"","text":"Load up to 4 bytes from a memory address."},{"tag":"param:addr","text":"Load up to 4 bytes from a memory address.\nAddress to a memory location."},{"tag":"param:size","text":"Load up to 4 bytes from a memory address.\nAddress to a memory location.How many bytes should be read."},{"tag":"return","text":"Load up to 4 bytes from a memory address.\nAddress to a memory location.How many bytes should be read.The value that is stored at that address."}]},"kind":"native","returnType":"int","arguments":[{"type":"Address","name":"addr","decl":"Address addr"},{"type":"NumberType","name":"size","decl":"NumberType size"}]},{"name":"StoreToAddress","docStart":26027,"docEnd":26254,"docs":{"brief":"Store up to 4 bytes to a memory address.","tags":[{"tag":"","text":"Store up to 4 bytes to a memory address."},{"tag":"param:addr","text":"Store up to 4 bytes to a memory address.\nAddress to a memory location."},{"tag":"param:data","text":"Store up to 4 bytes to a memory address.\nAddress to a memory location.Value to store at the address."},{"tag":"param:size","text":"Store up to 4 bytes to a memory address.\nAddress to a memory location.Value to store at the address.How many bytes should be written."}]},"kind":"native","returnType":"void","arguments":[{"type":"Address","name":"addr","decl":"Address addr"},{"type":"int","name":"data","decl":"int data"},{"type":"NumberType","name":"size","decl":"NumberType size"}]}],"methodmaps":[{"name":"GameData","docStart":0,"docEnd":0,"docs":null,"methods":[{"name":"GameData","docStart":2853,"docEnd":3144,"docs":{"brief":"Loads a game config file.","tags":[{"tag":"","text":"Loads a game config file."},{"tag":"param:file","text":"Loads a game config file.\nFile to load.  The path must be relative to the 'gamedata' folder under the config folderand the extension should be omitted."},{"tag":"return","text":"Loads a game config file.\nFile to load.  The path must be relative to the 'gamedata' folder under the config folderand the extension should be omitted.A handle to the game config file or null on failure"}]},"kind":null,"returnType":"GameData","arguments":[{"type":"const char[]","name":"file","decl":"const char[] file"}]},{"name":"GetOffset","docStart":3194,"docEnd":3348,"docs":{"brief":"Returns an offset value.","tags":[{"tag":"","text":"Returns an offset value."},{"tag":"param:key","text":"Returns an offset value.\nKey to retrieve from the offset section."},{"tag":"return","text":"Returns an offset value.\nKey to retrieve from the offset section.An offset, or -1 on failure"}]},"kind":null,"returnType":"int","arguments":[{"type":"const char[]","name":"key","decl":"const char[] key"}]},{"name":"GetKeyValue","docStart":3402,"docEnd":3706,"docs":{"brief":"Gets the value of a key from the \"Keys\" section.","tags":[{"tag":"","text":"Gets the value of a key from the \"Keys\" section."},{"tag":"param:key","text":"Gets the value of a key from the \"Keys\" section.\nKey to retrieve from the Keys section."},{"tag":"param:buffer","text":"Gets the value of a key from the \"Keys\" section.\nKey to retrieve from the Keys section.Destination string buffer."},{"tag":"param:maxlen","text":"Gets the value of a key from the \"Keys\" section.\nKey to retrieve from the Keys section.Destination string buffer.Maximum length of output string buffer."},{"tag":"return","text":"Gets the value of a key from the \"Keys\" section.\nKey to retrieve from the Keys section.Destination string buffer.Maximum length of output string buffer.True if key existed, false otherwise"}]},"kind":null,"returnType":"bool","arguments":[{"type":"const char[]","name":"key","decl":"const char[] key"},{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlen","decl":"int maxlen"}]},{"name":"GetAddress","docStart":3790,"docEnd":4065,"docs":{"brief":"Finds an address calculation in a GameConfig file,performs LoadFromAddress on it as appropriate, then returns the final address.","tags":[{"tag":"","text":"Finds an address calculation in a GameConfig file,performs LoadFromAddress on it as appropriate, then returns the final address."},{"tag":"param:name","text":"Finds an address calculation in a GameConfig file,performs LoadFromAddress on it as appropriate, then returns the final address.\nName of the property to find."},{"tag":"return","text":"Finds an address calculation in a GameConfig file,performs LoadFromAddress on it as appropriate, then returns the final address.\nName of the property to find.An address calculated on success, or 0 on failure"}]},"kind":null,"returnType":"Address","arguments":[{"type":"const char[]","name":"name","decl":"const char[] name"}]}],"properties":[]},{"name":"FrameIterator","docStart":0,"docEnd":0,"docs":null,"methods":[{"name":"FrameIterator","docStart":26365,"docEnd":26487,"docs":{"brief":"Creates a stack frame iterator to build your own stack traces.","tags":[{"tag":"","text":"Creates a stack frame iterator to build your own stack traces."},{"tag":"return","text":"Creates a stack frame iterator to build your own stack traces.New handle to a FrameIterator"}]},"kind":null,"returnType":"FrameIterator","arguments":[]},{"name":"Next","docStart":26525,"docEnd":26722,"docs":{"brief":"Advances the iterator to the next stack frame.","tags":[{"tag":"","text":"Advances the iterator to the next stack frame."},{"tag":"return","text":"Advances the iterator to the next stack frame.True if another frame was fetched and data can be successfully read."},{"tag":"error","text":"Advances the iterator to the next stack frame.True if another frame was fetched and data can be successfully read.No next element exception"}]},"kind":null,"returnType":"bool","arguments":[]},{"name":"Reset","docStart":26756,"docEnd":26810,"docs":{"brief":"Resets the iterator back to it's starting position","tags":[{"tag":"","text":"Resets the iterator back to it's starting position"}]},"kind":null,"returnType":"void","arguments":[]},{"name":"GetFunctionName","docStart":26962,"docEnd":27107,"docs":{"brief":"Gets the name of the current function in the call stack.","tags":[{"tag":"","text":"Gets the name of the current function in the call stack."},{"tag":"param:buffer","text":"Gets the name of the current function in the call stack.\nBuffer to copy to."},{"tag":"param:maxlen","text":"Gets the name of the current function in the call stack.\nBuffer to copy to.Max size of the buffer"}]},"kind":null,"returnType":"void","arguments":[{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlen","decl":"int maxlen"}]},{"name":"GetFilePath","docStart":27177,"docEnd":27323,"docs":{"brief":"Gets the file path to the current call in the call stack.","tags":[{"tag":"","text":"Gets the file path to the current call in the call stack."},{"tag":"param:buffer","text":"Gets the file path to the current call in the call stack.\nBuffer to copy to."},{"tag":"param:maxlen","text":"Gets the file path to the current call in the call stack.\nBuffer to copy to.Max size of the buffer"}]},"kind":null,"returnType":"void","arguments":[{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlen","decl":"int maxlen"}]}],"properties":[{"name":"LineNumber","docStart":26845,"docEnd":26901,"docs":{"brief":"Returns the line number of the current function call","tags":[{"tag":"","text":"Returns the line number of the current function call"}]},"type":"int","getter":true,"setter":false}]}],"constants":[],"enums":[{"name":"APLRes","docStart":0,"docEnd":0,"docs":null,"entries":[{"name":"APLRes_Success","docStart":2627,"docEnd":2653,"docs":null},{"name":"APLRes_Failure","docStart":2680,"docEnd":2737,"docs":null},{"name":"APLRes_SilentFailure","docStart":2764,"docEnd":2812,"docs":null}]},{"name":"FeatureType","docStart":23507,"docEnd":23534,"docs":{"brief":"Feature types.","tags":[{"tag":"","text":"Feature types."}]},"entries":[{"name":"FeatureType_Native","docStart":23558,"docEnd":23596,"docs":null},{"name":"FeatureType_Capability","docStart":23623,"docEnd":23971,"docs":null}]},{"name":"FeatureStatus","docStart":24004,"docEnd":24034,"docs":{"brief":"Feature statuses.","tags":[{"tag":"","text":"Feature statuses."}]},"entries":[{"name":"FeatureStatus_Available","docStart":24060,"docEnd":24104,"docs":null},{"name":"FeatureStatus_Unavailable","docStart":24136,"docEnd":24176,"docs":null},{"name":"FeatureStatus_Unknown","docStart":24210,"docEnd":24253,"docs":null}]},{"name":"NumberType","docStart":25436,"docEnd":25516,"docs":{"brief":"Represents how many bytes we can read from an address with one load","tags":[{"tag":"","text":"Represents how many bytes we can read from an address with one load"}]},"entries":[{"name":"NumberType_Int8","docStart":0,"docEnd":0,"docs":null},{"name":"NumberType_Int16","docStart":0,"docEnd":0,"docs":null},{"name":"NumberType_Int32","docStart":0,"docEnd":0,"docs":null}]},{"name":"Address","docStart":0,"docEnd":0,"docs":null,"entries":[{"name":"Address_Null","docStart":25663,"docEnd":25719,"docs":null}]}],"typesets":[],"typedefs":[]}