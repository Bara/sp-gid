{"functions":[{"name":"strlen","docStart":1899,"docEnd":2064,"docs":{"brief":"Calculates the length of a string.","tags":[{"tag":"","text":"Calculates the length of a string."},{"tag":"param:str","text":"Calculates the length of a string.\nString to check."},{"tag":"return","text":"Calculates the length of a string.\nString to check.Number of valid character bytes in the string."}]},"kind":"native","returnType":"int","arguments":[{"type":"const char[]","name":"str","decl":"const char[] str"}]},{"name":"StrContains","docStart":2106,"docEnd":2584,"docs":{"brief":"Tests whether a string is found inside another string.","tags":[{"tag":"","text":"Tests whether a string is found inside another string."},{"tag":"param:str","text":"Tests whether a string is found inside another string.\nString to search in."},{"tag":"param:substr","text":"Tests whether a string is found inside another string.\nString to search in.Substring to find inside the original string."},{"tag":"param:caseSensitive","text":"Tests whether a string is found inside another string.\nString to search in.Substring to find inside the original string.If true (default), search is case sensitive.If false, search is case insensitive."},{"tag":"return","text":"Tests whether a string is found inside another string.\nString to search in.Substring to find inside the original string.If true (default), search is case sensitive.If false, search is case insensitive.-1 on failure (no match found). Any other valueindicates a position in the string where the match starts."}]},"kind":"native","returnType":"int","arguments":[{"type":"const char[]","name":"str","decl":"const char[] str"},{"type":"const char[]","name":"substr","decl":"const char[] substr"},{"type":"bool","name":"caseSensitive","decl":"bool caseSensitive"}]},{"name":"strcmp","docStart":2677,"docEnd":3094,"docs":{"brief":"Compares two strings lexographically.","tags":[{"tag":"","text":"Compares two strings lexographically."},{"tag":"param:str1","text":"Compares two strings lexographically.\nFirst string (left)."},{"tag":"param:str2","text":"Compares two strings lexographically.\nFirst string (left).Second string (right)."},{"tag":"param:caseSensitive","text":"Compares two strings lexographically.\nFirst string (left).Second string (right).If true (default), comparison is case sensitive.If false, comparison is case insensitive."},{"tag":"return","text":"Compares two strings lexographically.\nFirst string (left).Second string (right).If true (default), comparison is case sensitive.If false, comparison is case insensitive.-1 if str1 < str20 if str1 == str21 if str1 > str2"}]},"kind":"native","returnType":"int","arguments":[{"type":"const char[]","name":"str1","decl":"const char[] str1"},{"type":"const char[]","name":"str2","decl":"const char[] str2"},{"type":"bool","name":"caseSensitive","decl":"bool caseSensitive"}]},{"name":"strncmp","docStart":3181,"docEnd":3662,"docs":{"brief":"Compares two strings parts lexographically.","tags":[{"tag":"","text":"Compares two strings parts lexographically."},{"tag":"param:str1","text":"Compares two strings parts lexographically.\nFirst string (left)."},{"tag":"param:str2","text":"Compares two strings parts lexographically.\nFirst string (left).Second string (right)."},{"tag":"param:num","text":"Compares two strings parts lexographically.\nFirst string (left).Second string (right).Number of characters to compare."},{"tag":"param:caseSensitive","text":"Compares two strings parts lexographically.\nFirst string (left).Second string (right).Number of characters to compare.If true (default), comparison is case sensitive.If false, comparison is case insensitive."},{"tag":"return","text":"Compares two strings parts lexographically.\nFirst string (left).Second string (right).Number of characters to compare.If true (default), comparison is case sensitive.If false, comparison is case insensitive.-1 if str1 < str20 if str1 == str21 if str1 > str2"}]},"kind":"native","returnType":"int","arguments":[{"type":"const char[]","name":"str1","decl":"const char[] str1"},{"type":"const char[]","name":"str2","decl":"const char[] str2"},{"type":"int","name":"num","decl":"int num"},{"type":"bool","name":"caseSensitive","decl":"bool caseSensitive"}]},{"name":"StrCompare","docStart":0,"docEnd":0,"docs":null,"kind":"stock","returnType":"int","arguments":[{"type":"const char[]","name":"str1","decl":"const char[] str1"},{"type":"const char[]","name":"str2","decl":"const char[] str2"},{"type":"bool","name":"caseSensitive","decl":"bool caseSensitive"}]},{"name":"StrEqual","docStart":4048,"docEnd":4395,"docs":{"brief":"Returns whether two strings are equal.","tags":[{"tag":"","text":"Returns whether two strings are equal."},{"tag":"param:str1","text":"Returns whether two strings are equal.\nFirst string (left)."},{"tag":"param:str2","text":"Returns whether two strings are equal.\nFirst string (left).Second string (right)."},{"tag":"param:caseSensitive","text":"Returns whether two strings are equal.\nFirst string (left).Second string (right).If true (default), comparison is case sensitive.If false, comparison is case insensitive."},{"tag":"return","text":"Returns whether two strings are equal.\nFirst string (left).Second string (right).If true (default), comparison is case sensitive.If false, comparison is case insensitive.True if equal, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"str1","decl":"const char[] str1"},{"type":"const char[]","name":"str2","decl":"const char[] str2"},{"type":"bool","name":"caseSensitive","decl":"bool caseSensitive"}]},{"name":"strcopy","docStart":4540,"docEnd":4967,"docs":{"brief":"Copies one string to another string.","tags":[{"tag":"","text":"Copies one string to another string."},{"tag":"note","text":"Copies one string to another string.If the destination buffer is too small to hold the source string, thedestination will be truncated."},{"tag":"param:dest","text":"Copies one string to another string.If the destination buffer is too small to hold the source string, thedestination will be truncated.\nDestination string buffer to copy to."},{"tag":"param:destLen","text":"Copies one string to another string.If the destination buffer is too small to hold the source string, thedestination will be truncated.\nDestination string buffer to copy to.Destination buffer length (includes null terminator)."},{"tag":"param:source","text":"Copies one string to another string.If the destination buffer is too small to hold the source string, thedestination will be truncated.\nDestination string buffer to copy to.Destination buffer length (includes null terminator).Source string buffer to copy from."},{"tag":"return","text":"Copies one string to another string.If the destination buffer is too small to hold the source string, thedestination will be truncated.\nDestination string buffer to copy to.Destination buffer length (includes null terminator).Source string buffer to copy from.Number of cells written."}]},"kind":"native","returnType":"int","arguments":[{"type":"char[]","name":"dest","decl":"char[] dest"},{"type":"int","name":"destLen","decl":"int destLen"},{"type":"const char[]","name":"source","decl":"const char[] source"}]},{"name":"StrCopy","docStart":0,"docEnd":0,"docs":null,"kind":"stock","returnType":"int","arguments":[{"type":"char[]","name":"dest","decl":"char[] dest"},{"type":"int","name":"destLen","decl":"int destLen"},{"type":"const char[]","name":"source","decl":"const char[] source"}]},{"name":"Format","docStart":5298,"docEnd":5665,"docs":{"brief":"Formats a string according to the SourceMod format rules (see documentation).","tags":[{"tag":"","text":"Formats a string according to the SourceMod format rules (see documentation)."},{"tag":"param:buffer","text":"Formats a string according to the SourceMod format rules (see documentation).\nDestination string buffer."},{"tag":"param:maxlength","text":"Formats a string according to the SourceMod format rules (see documentation).\nDestination string buffer.Maximum length of output string buffer."},{"tag":"param:format","text":"Formats a string according to the SourceMod format rules (see documentation).\nDestination string buffer.Maximum length of output string buffer.Formatting rules."},{"tag":"param:...","text":"Formats a string according to the SourceMod format rules (see documentation).\nDestination string buffer.Maximum length of output string buffer.Formatting rules.Variable number of format parameters."},{"tag":"return","text":"Formats a string according to the SourceMod format rules (see documentation).\nDestination string buffer.Maximum length of output string buffer.Formatting rules.Variable number of format parameters.Number of cells written."}]},"kind":"native","returnType":"int","arguments":[{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlength","decl":"int maxlength"},{"type":"const char[]","name":"format","decl":"const char[] format"},{"type":"any...","name":"...","decl":"any... ..."}]},{"name":"FormatEx","docStart":5749,"docEnd":6323,"docs":{"brief":"Formats a string according to the SourceMod format rules (see documentation).","tags":[{"tag":"","text":"Formats a string according to the SourceMod format rules (see documentation)."},{"tag":"note","text":"Formats a string according to the SourceMod format rules (see documentation).This is the same as Format(), except none of the input buffers canoverlap the same memory as the output buffer.  Since this securitycheck is removed, it is slightly faster."},{"tag":"param:buffer","text":"Formats a string according to the SourceMod format rules (see documentation).This is the same as Format(), except none of the input buffers canoverlap the same memory as the output buffer.  Since this securitycheck is removed, it is slightly faster.\nDestination string buffer."},{"tag":"param:maxlength","text":"Formats a string according to the SourceMod format rules (see documentation).This is the same as Format(), except none of the input buffers canoverlap the same memory as the output buffer.  Since this securitycheck is removed, it is slightly faster.\nDestination string buffer.Maximum length of output string buffer."},{"tag":"param:format","text":"Formats a string according to the SourceMod format rules (see documentation).This is the same as Format(), except none of the input buffers canoverlap the same memory as the output buffer.  Since this securitycheck is removed, it is slightly faster.\nDestination string buffer.Maximum length of output string buffer.Formatting rules."},{"tag":"param:...","text":"Formats a string according to the SourceMod format rules (see documentation).This is the same as Format(), except none of the input buffers canoverlap the same memory as the output buffer.  Since this securitycheck is removed, it is slightly faster.\nDestination string buffer.Maximum length of output string buffer.Formatting rules.Variable number of format parameters."},{"tag":"return","text":"Formats a string according to the SourceMod format rules (see documentation).This is the same as Format(), except none of the input buffers canoverlap the same memory as the output buffer.  Since this securitycheck is removed, it is slightly faster.\nDestination string buffer.Maximum length of output string buffer.Formatting rules.Variable number of format parameters.Number of cells written."}]},"kind":"native","returnType":"int","arguments":[{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlength","decl":"int maxlength"},{"type":"const char[]","name":"format","decl":"const char[] format"},{"type":"any...","name":"...","decl":"any... ..."}]},{"name":"VFormat","docStart":6409,"docEnd":7052,"docs":{"brief":"Formats a string according to the SourceMod format rules (see documentation).","tags":[{"tag":"","text":"Formats a string according to the SourceMod format rules (see documentation)."},{"tag":"note","text":"Formats a string according to the SourceMod format rules (see documentation).This is the same as Format(), except it grabs parameters from aparent parameter stack, rather than a local.  This is useful forimplementing your own variable argument functions."},{"tag":"param:buffer","text":"Formats a string according to the SourceMod format rules (see documentation).This is the same as Format(), except it grabs parameters from aparent parameter stack, rather than a local.  This is useful forimplementing your own variable argument functions.\nDestination string buffer."},{"tag":"param:maxlength","text":"Formats a string according to the SourceMod format rules (see documentation).This is the same as Format(), except it grabs parameters from aparent parameter stack, rather than a local.  This is useful forimplementing your own variable argument functions.\nDestination string buffer.Maximum length of output string buffer."},{"tag":"param:format","text":"Formats a string according to the SourceMod format rules (see documentation).This is the same as Format(), except it grabs parameters from aparent parameter stack, rather than a local.  This is useful forimplementing your own variable argument functions.\nDestination string buffer.Maximum length of output string buffer.Formatting rules."},{"tag":"param:varpos","text":"Formats a string according to the SourceMod format rules (see documentation).This is the same as Format(), except it grabs parameters from aparent parameter stack, rather than a local.  This is useful forimplementing your own variable argument functions.\nDestination string buffer.Maximum length of output string buffer.Formatting rules.Argument number which contains the '...' symbol.Note: Arguments start at 1."},{"tag":"return","text":"Formats a string according to the SourceMod format rules (see documentation).This is the same as Format(), except it grabs parameters from aparent parameter stack, rather than a local.  This is useful forimplementing your own variable argument functions.\nDestination string buffer.Maximum length of output string buffer.Formatting rules.Argument number which contains the '...' symbol.Note: Arguments start at 1.Number of bytes written."}]},"kind":"native","returnType":"int","arguments":[{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlength","decl":"int maxlength"},{"type":"const char[]","name":"format","decl":"const char[] format"},{"type":"int","name":"varpos","decl":"int varpos"}]},{"name":"StringToInt","docStart":7140,"docEnd":7369,"docs":{"brief":"Converts a string to an integer.","tags":[{"tag":"","text":"Converts a string to an integer."},{"tag":"param:str","text":"Converts a string to an integer.\nString to convert."},{"tag":"param:nBase","text":"Converts a string to an integer.\nString to convert.Numerical base to use.  10 is default."},{"tag":"return","text":"Converts a string to an integer.\nString to convert.Numerical base to use.  10 is default.Integer conversion of string, or 0 on failure."}]},"kind":"native","returnType":"int","arguments":[{"type":"const char[]","name":"str","decl":"const char[] str"},{"type":"int","name":"nBase","decl":"int nBase"}]},{"name":"StringToIntEx","docStart":7430,"docEnd":7724,"docs":{"brief":"Converts a string to an integer with some more options.","tags":[{"tag":"","text":"Converts a string to an integer with some more options."},{"tag":"param:str","text":"Converts a string to an integer with some more options.\nString to convert."},{"tag":"param:result","text":"Converts a string to an integer with some more options.\nString to convert.Variable to store the result in."},{"tag":"param:nBase","text":"Converts a string to an integer with some more options.\nString to convert.Variable to store the result in.Numerical base to use.  10 is default."},{"tag":"return","text":"Converts a string to an integer with some more options.\nString to convert.Variable to store the result in.Numerical base to use.  10 is default.Number of characters consumed."}]},"kind":"native","returnType":"int","arguments":[{"type":"const char[]","name":"str","decl":"const char[] str"},{"type":"int&","name":"result","decl":"int& result"},{"type":"int","name":"nBase","decl":"int nBase"}]},{"name":"IntToString","docStart":7800,"docEnd":8064,"docs":{"brief":"Converts an integer to a string.","tags":[{"tag":"","text":"Converts an integer to a string."},{"tag":"param:num","text":"Converts an integer to a string.\nInteger to convert."},{"tag":"param:str","text":"Converts an integer to a string.\nInteger to convert.Buffer to store string in."},{"tag":"param:maxlength","text":"Converts an integer to a string.\nInteger to convert.Buffer to store string in.Maximum length of string buffer."},{"tag":"return","text":"Converts an integer to a string.\nInteger to convert.Buffer to store string in.Maximum length of string buffer.Number of cells written to buffer."}]},"kind":"native","returnType":"int","arguments":[{"type":"int","name":"num","decl":"int num"},{"type":"char[]","name":"str","decl":"char[] str"},{"type":"int","name":"maxlength","decl":"int maxlength"}]},{"name":"StringToFloat","docStart":8129,"docEnd":8312,"docs":{"brief":"Converts a string to a floating point number.","tags":[{"tag":"","text":"Converts a string to a floating point number."},{"tag":"param:str","text":"Converts a string to a floating point number.\nString to convert to a float."},{"tag":"return","text":"Converts a string to a floating point number.\nString to convert to a float.Floating point result, or 0.0 on error."}]},"kind":"native","returnType":"float","arguments":[{"type":"const char[]","name":"str","decl":"const char[] str"}]},{"name":"StringToFloatEx","docStart":8363,"docEnd":8614,"docs":{"brief":"Converts a string to a floating point number with some more options.","tags":[{"tag":"","text":"Converts a string to a floating point number with some more options."},{"tag":"param:str","text":"Converts a string to a floating point number with some more options.\nString to convert to a float."},{"tag":"param:result","text":"Converts a string to a floating point number with some more options.\nString to convert to a float.Variable to store result in."},{"tag":"return","text":"Converts a string to a floating point number with some more options.\nString to convert to a float.Variable to store result in.Number of characters consumed."}]},"kind":"native","returnType":"int","arguments":[{"type":"const char[]","name":"str","decl":"const char[] str"},{"type":"float&","name":"result","decl":"float& result"}]},{"name":"FloatToString","docStart":8680,"docEnd":8971,"docs":{"brief":"Converts a floating point number to a string.","tags":[{"tag":"","text":"Converts a floating point number to a string."},{"tag":"param:num","text":"Converts a floating point number to a string.\nFloating point number to convert."},{"tag":"param:str","text":"Converts a floating point number to a string.\nFloating point number to convert.Buffer to store string in."},{"tag":"param:maxlength","text":"Converts a floating point number to a string.\nFloating point number to convert.Buffer to store string in.Maximum length of string buffer."},{"tag":"return","text":"Converts a floating point number to a string.\nFloating point number to convert.Buffer to store string in.Maximum length of string buffer.Number of cells written to buffer."}]},"kind":"native","returnType":"int","arguments":[{"type":"float","name":"num","decl":"float num"},{"type":"char[]","name":"str","decl":"char[] str"},{"type":"int","name":"maxlength","decl":"int maxlength"}]},{"name":"BreakString","docStart":9040,"docEnd":9612,"docs":{"brief":"Finds the first \"argument\" in a string; either a set of spaceterminated characters, or a fully quoted string.  After theargument is found, whitespace is read until the next portionof the string is reached.  If nothing remains, -1 is returned.Otherwise, the index to the first character is returned.","tags":[{"tag":"","text":"Finds the first \"argument\" in a string; either a set of spaceterminated characters, or a fully quoted string.  After theargument is found, whitespace is read until the next portionof the string is reached.  If nothing remains, -1 is returned.Otherwise, the index to the first character is returned."},{"tag":"param:source","text":"Finds the first \"argument\" in a string; either a set of spaceterminated characters, or a fully quoted string.  After theargument is found, whitespace is read until the next portionof the string is reached.  If nothing remains, -1 is returned.Otherwise, the index to the first character is returned.\nSource input string."},{"tag":"param:arg","text":"Finds the first \"argument\" in a string; either a set of spaceterminated characters, or a fully quoted string.  After theargument is found, whitespace is read until the next portionof the string is reached.  If nothing remains, -1 is returned.Otherwise, the index to the first character is returned.\nSource input string.Stores argument read from string."},{"tag":"param:argLen","text":"Finds the first \"argument\" in a string; either a set of spaceterminated characters, or a fully quoted string.  After theargument is found, whitespace is read until the next portionof the string is reached.  If nothing remains, -1 is returned.Otherwise, the index to the first character is returned.\nSource input string.Stores argument read from string.Maximum length of argument buffer."},{"tag":"return","text":"Finds the first \"argument\" in a string; either a set of spaceterminated characters, or a fully quoted string.  After theargument is found, whitespace is read until the next portionof the string is reached.  If nothing remains, -1 is returned.Otherwise, the index to the first character is returned.\nSource input string.Stores argument read from string.Maximum length of argument buffer.Index to next piece of string, or -1 if none."}]},"kind":"native","returnType":"int","arguments":[{"type":"const char[]","name":"source","decl":"const char[] source"},{"type":"char[]","name":"arg","decl":"char[] arg"},{"type":"int","name":"argLen","decl":"int argLen"}]},{"name":"StrBreak","docStart":0,"docEnd":0,"docs":null,"kind":"stock","returnType":"int","arguments":[{"type":"const char[]","name":"source","decl":"const char[] source"},{"type":"char[]","name":"arg","decl":"char[] arg"},{"type":"int","name":"argLen","decl":"int argLen"}]},{"name":"TrimString","docStart":9959,"docEnd":10153,"docs":{"brief":"Removes whitespace characters from the beginning and end of a string.","tags":[{"tag":"","text":"Removes whitespace characters from the beginning and end of a string."},{"tag":"param:str","text":"Removes whitespace characters from the beginning and end of a string.\nThe string to trim."},{"tag":"return","text":"Removes whitespace characters from the beginning and end of a string.\nThe string to trim.Number of bytes written (UTF-8 safe)."}]},"kind":"native","returnType":"int","arguments":[{"type":"char[]","name":"str","decl":"char[] str"}]},{"name":"SplitString","docStart":10193,"docEnd":10775,"docs":{"brief":"Returns text in a string up until a certain character sequence is reached.","tags":[{"tag":"","text":"Returns text in a string up until a certain character sequence is reached."},{"tag":"param:source","text":"Returns text in a string up until a certain character sequence is reached.\nSource input string."},{"tag":"param:split","text":"Returns text in a string up until a certain character sequence is reached.\nSource input string.A string which specifies a search point to break at."},{"tag":"param:part","text":"Returns text in a string up until a certain character sequence is reached.\nSource input string.A string which specifies a search point to break at.Buffer to store string part."},{"tag":"param:partLen","text":"Returns text in a string up until a certain character sequence is reached.\nSource input string.A string which specifies a search point to break at.Buffer to store string part.Maximum length of the string part buffer."},{"tag":"return","text":"Returns text in a string up until a certain character sequence is reached.\nSource input string.A string which specifies a search point to break at.Buffer to store string part.Maximum length of the string part buffer.-1 if no match was found; otherwise, an index into sourcemarking the first index after the searched text.  Theindex is always relative to the start of the input string."}]},"kind":"native","returnType":"int","arguments":[{"type":"const char[]","name":"source","decl":"const char[] source"},{"type":"const char[]","name":"split","decl":"const char[] split"},{"type":"char[]","name":"part","decl":"char[] part"},{"type":"int","name":"partLen","decl":"int partLen"}]},{"name":"ReplaceString","docStart":10871,"docEnd":11365,"docs":{"brief":"Given a string, replaces all occurrences of a search string with areplacement string.","tags":[{"tag":"","text":"Given a string, replaces all occurrences of a search string with areplacement string."},{"tag":"param:text","text":"Given a string, replaces all occurrences of a search string with areplacement string.\nString to perform search and replacements on."},{"tag":"param:maxlength","text":"Given a string, replaces all occurrences of a search string with areplacement string.\nString to perform search and replacements on.Maximum length of the string buffer."},{"tag":"param:search","text":"Given a string, replaces all occurrences of a search string with areplacement string.\nString to perform search and replacements on.Maximum length of the string buffer.String to search for."},{"tag":"param:replace","text":"Given a string, replaces all occurrences of a search string with areplacement string.\nString to perform search and replacements on.Maximum length of the string buffer.String to search for.String to replace the search string with."},{"tag":"param:caseSensitive","text":"Given a string, replaces all occurrences of a search string with areplacement string.\nString to perform search and replacements on.Maximum length of the string buffer.String to search for.String to replace the search string with.If true (default), search is case sensitive."},{"tag":"return","text":"Given a string, replaces all occurrences of a search string with areplacement string.\nString to perform search and replacements on.Maximum length of the string buffer.String to search for.String to replace the search string with.If true (default), search is case sensitive.Number of replacements that were performed."}]},"kind":"native","returnType":"int","arguments":[{"type":"char[]","name":"text","decl":"char[] text"},{"type":"int","name":"maxlength","decl":"int maxlength"},{"type":"const char[]","name":"search","decl":"const char[] search"},{"type":"const char[]","name":"replace","decl":"const char[] replace"},{"type":"bool","name":"caseSensitive","decl":"bool caseSensitive"}]},{"name":"ReplaceStringEx","docStart":11492,"docEnd":12407,"docs":{"brief":"Given a string, replaces the first occurrence of a search string with areplacement string.","tags":[{"tag":"","text":"Given a string, replaces the first occurrence of a search string with areplacement string."},{"tag":"param:text","text":"Given a string, replaces the first occurrence of a search string with areplacement string.\nString to perform search and replacements on."},{"tag":"param:maxlength","text":"Given a string, replaces the first occurrence of a search string with areplacement string.\nString to perform search and replacements on.Maximum length of the string buffer."},{"tag":"param:search","text":"Given a string, replaces the first occurrence of a search string with areplacement string.\nString to perform search and replacements on.Maximum length of the string buffer.String to search for."},{"tag":"param:replace","text":"Given a string, replaces the first occurrence of a search string with areplacement string.\nString to perform search and replacements on.Maximum length of the string buffer.String to search for.String to replace the search string with."},{"tag":"param:searchLen","text":"Given a string, replaces the first occurrence of a search string with areplacement string.\nString to perform search and replacements on.Maximum length of the string buffer.String to search for.String to replace the search string with.If higher than -1, its value will be used instead ofa strlen() call on the search parameter."},{"tag":"param:replaceLen","text":"Given a string, replaces the first occurrence of a search string with areplacement string.\nString to perform search and replacements on.Maximum length of the string buffer.String to search for.String to replace the search string with.If higher than -1, its value will be used instead ofa strlen() call on the search parameter.If higher than -1, its value will be used instead ofa strlen() call on the replace parameter."},{"tag":"param:caseSensitive","text":"Given a string, replaces the first occurrence of a search string with areplacement string.\nString to perform search and replacements on.Maximum length of the string buffer.String to search for.String to replace the search string with.If higher than -1, its value will be used instead ofa strlen() call on the search parameter.If higher than -1, its value will be used instead ofa strlen() call on the replace parameter.If true (default), search is case sensitive."},{"tag":"return","text":"Given a string, replaces the first occurrence of a search string with areplacement string.\nString to perform search and replacements on.Maximum length of the string buffer.String to search for.String to replace the search string with.If higher than -1, its value will be used instead ofa strlen() call on the search parameter.If higher than -1, its value will be used instead ofa strlen() call on the replace parameter.If true (default), search is case sensitive.Index into the buffer (relative to the start) from wherethe last replacement ended, or -1 if no replacements weremade."}]},"kind":"native","returnType":"int","arguments":[{"type":"char[]","name":"text","decl":"char[] text"},{"type":"int","name":"maxlength","decl":"int maxlength"},{"type":"const char[]","name":"search","decl":"const char[] search"},{"type":"const char[]","name":"replace","decl":"const char[] replace"},{"type":"int","name":"searchLen","decl":"int searchLen"},{"type":"int","name":"replaceLen","decl":"int replaceLen"},{"type":"bool","name":"caseSensitive","decl":"bool caseSensitive"}]},{"name":"GetCharBytes","docStart":12573,"docEnd":12857,"docs":{"brief":"Returns the number of bytes a character is using.  This isfor multi-byte characters (UTF-8).  For normal ASCII characters,this will return 1.","tags":[{"tag":"","text":"Returns the number of bytes a character is using.  This isfor multi-byte characters (UTF-8).  For normal ASCII characters,this will return 1."},{"tag":"param:source","text":"Returns the number of bytes a character is using.  This isfor multi-byte characters (UTF-8).  For normal ASCII characters,this will return 1.\nSource input string."},{"tag":"return","text":"Returns the number of bytes a character is using.  This isfor multi-byte characters (UTF-8).  For normal ASCII characters,this will return 1.\nSource input string.Number of bytes the current character uses."}]},"kind":"native","returnType":"int","arguments":[{"type":"const char[]","name":"source","decl":"const char[] source"}]},{"name":"IsCharAlpha","docStart":12908,"docEnd":13167,"docs":{"brief":"Returns whether a character is an ASCII alphabet character.","tags":[{"tag":"","text":"Returns whether a character is an ASCII alphabet character."},{"tag":"note","text":"Returns whether a character is an ASCII alphabet character.\nMulti-byte characters will always return false."},{"tag":"param:chr","text":"Returns whether a character is an ASCII alphabet character.\nMulti-byte characters will always return false.\nCharacter to test."},{"tag":"return","text":"Returns whether a character is an ASCII alphabet character.\nMulti-byte characters will always return false.\nCharacter to test.True if character is alphabetical, otherwise false."}]},"kind":"native","returnType":"bool","arguments":[{"type":"int","name":"chr","decl":"int chr"}]},{"name":"IsCharNumeric","docStart":13206,"docEnd":13440,"docs":{"brief":"Returns whether a character is numeric.","tags":[{"tag":"","text":"Returns whether a character is numeric."},{"tag":"note","text":"Returns whether a character is numeric.\nMulti-byte characters will always return false."},{"tag":"param:chr","text":"Returns whether a character is numeric.\nMulti-byte characters will always return false.\nCharacter to test."},{"tag":"return","text":"Returns whether a character is numeric.\nMulti-byte characters will always return false.\nCharacter to test.True if character is numeric, otherwise false."}]},"kind":"native","returnType":"bool","arguments":[{"type":"int","name":"chr","decl":"int chr"}]},{"name":"IsCharSpace","docStart":13481,"docEnd":13721,"docs":{"brief":"Returns whether a character is whitespace.","tags":[{"tag":"","text":"Returns whether a character is whitespace."},{"tag":"note","text":"Returns whether a character is whitespace.\nMulti-byte characters will always return false."},{"tag":"param:chr","text":"Returns whether a character is whitespace.\nMulti-byte characters will always return false.\nCharacter to test."},{"tag":"return","text":"Returns whether a character is whitespace.\nMulti-byte characters will always return false.\nCharacter to test.True if character is whitespace, otherwise false."}]},"kind":"native","returnType":"bool","arguments":[{"type":"int","name":"chr","decl":"int chr"}]},{"name":"IsCharMB","docStart":13760,"docEnd":14004,"docs":{"brief":"Returns if a character is multi-byte or not.","tags":[{"tag":"","text":"Returns if a character is multi-byte or not."},{"tag":"param:chr","text":"Returns if a character is multi-byte or not.\nCharacter to test."},{"tag":"return","text":"Returns if a character is multi-byte or not.\nCharacter to test.0 for a normal 7-bit ASCII character,otherwise number of bytes in multi-byte character."}]},"kind":"native","returnType":"int","arguments":[{"type":"int","name":"chr","decl":"int chr"}]},{"name":"IsCharUpper","docStart":14039,"docEnd":14289,"docs":{"brief":"Returns whether an alphabetic character is uppercase.","tags":[{"tag":"","text":"Returns whether an alphabetic character is uppercase."},{"tag":"note","text":"Returns whether an alphabetic character is uppercase.\nMulti-byte characters will always return false."},{"tag":"param:chr","text":"Returns whether an alphabetic character is uppercase.\nMulti-byte characters will always return false.\nCharacter to test."},{"tag":"return","text":"Returns whether an alphabetic character is uppercase.\nMulti-byte characters will always return false.\nCharacter to test.True if character is uppercase, otherwise false."}]},"kind":"native","returnType":"bool","arguments":[{"type":"int","name":"chr","decl":"int chr"}]},{"name":"IsCharLower","docStart":14328,"docEnd":14578,"docs":{"brief":"Returns whether an alphabetic character is lowercase.","tags":[{"tag":"","text":"Returns whether an alphabetic character is lowercase."},{"tag":"note","text":"Returns whether an alphabetic character is lowercase.\nMulti-byte characters will always return false."},{"tag":"param:chr","text":"Returns whether an alphabetic character is lowercase.\nMulti-byte characters will always return false.\nCharacter to test."},{"tag":"return","text":"Returns whether an alphabetic character is lowercase.\nMulti-byte characters will always return false.\nCharacter to test.True if character is lowercase, otherwise false."}]},"kind":"native","returnType":"bool","arguments":[{"type":"int","name":"chr","decl":"int chr"}]},{"name":"StripQuotes","docStart":14617,"docEnd":15143,"docs":{"brief":"Strips a quote pair off a string if it exists.  That is, the followingreplace rule is applied once:  ^\"(.*)\"$ -> ^\\1$\nNote that the leading and trailing quotes will only be removed if bothexist.  Otherwise, the string is left unmodified.  This function shouldbe considered O(k) (all characters get shifted down).","tags":[{"tag":"","text":"Strips a quote pair off a string if it exists.  That is, the followingreplace rule is applied once:  ^\"(.*)\"$ -> ^\\1$\nNote that the leading and trailing quotes will only be removed if bothexist.  Otherwise, the string is left unmodified.  This function shouldbe considered O(k) (all characters get shifted down)."},{"tag":"param:text","text":"Strips a quote pair off a string if it exists.  That is, the followingreplace rule is applied once:  ^\"(.*)\"$ -> ^\\1$\nNote that the leading and trailing quotes will only be removed if bothexist.  Otherwise, the string is left unmodified.  This function shouldbe considered O(k) (all characters get shifted down).\nString to modify (in place)."},{"tag":"return","text":"Strips a quote pair off a string if it exists.  That is, the followingreplace rule is applied once:  ^\"(.*)\"$ -> ^\\1$\nNote that the leading and trailing quotes will only be removed if bothexist.  Otherwise, the string is left unmodified.  This function shouldbe considered O(k) (all characters get shifted down).\nString to modify (in place).True if string was modified, false if there was noset of quotes."}]},"kind":"native","returnType":"bool","arguments":[{"type":"char[]","name":"text","decl":"char[] text"}]},{"name":"CharToUpper","docStart":15186,"docEnd":15415,"docs":{"brief":"Converts a lowercase character to its uppercase counterpart.","tags":[{"tag":"","text":"Converts a lowercase character to its uppercase counterpart."},{"tag":"param:chr","text":"Converts a lowercase character to its uppercase counterpart.\nCharacter to convert."},{"tag":"return","text":"Converts a lowercase character to its uppercase counterpart.\nCharacter to convert.Uppercase character on success,no change on failure."}]},"kind":"stock","returnType":"int","arguments":[{"type":"int","name":"chr","decl":"int chr"}]},{"name":"CharToLower","docStart":15532,"docEnd":15762,"docs":{"brief":"Converts an uppercase character to its lowercase counterpart.","tags":[{"tag":"","text":"Converts an uppercase character to its lowercase counterpart."},{"tag":"param:chr","text":"Converts an uppercase character to its lowercase counterpart.\nCharacter to convert."},{"tag":"return","text":"Converts an uppercase character to its lowercase counterpart.\nCharacter to convert.Lowercase character on success,no change on failure."}]},"kind":"stock","returnType":"int","arguments":[{"type":"int","name":"chr","decl":"int chr"}]},{"name":"FindCharInString","docStart":15879,"docEnd":16299,"docs":{"brief":"Finds the first occurrence of a character in a string.","tags":[{"tag":"","text":"Finds the first occurrence of a character in a string."},{"tag":"param:str","text":"Finds the first occurrence of a character in a string.\nString."},{"tag":"param:c","text":"Finds the first occurrence of a character in a string.\nString.Character to search for."},{"tag":"param:reverse","text":"Finds the first occurrence of a character in a string.\nString.Character to search for.False (default) to search forward, true to searchbackward."},{"tag":"return","text":"Finds the first occurrence of a character in a string.\nString.Character to search for.False (default) to search forward, true to searchbackward.The index of the first occurrence of the characterin the string, or -1 if the character was not found."}]},"kind":"stock","returnType":"int","arguments":[{"type":"const char[]","name":"str","decl":"const char[] str"},{"type":"char","name":"c","decl":"char c"},{"type":"bool","name":"reverse","decl":"bool reverse"}]},{"name":"StrCat","docStart":16654,"docEnd":16917,"docs":{"brief":"Concatenates one string onto another.","tags":[{"tag":"","text":"Concatenates one string onto another."},{"tag":"param:buffer","text":"Concatenates one string onto another.\nString to append to."},{"tag":"param:maxlength","text":"Concatenates one string onto another.\nString to append to.Maximum length of entire buffer."},{"tag":"param:source","text":"Concatenates one string onto another.\nString to append to.Maximum length of entire buffer.Source string to concatenate."},{"tag":"return","text":"Concatenates one string onto another.\nString to append to.Maximum length of entire buffer.Source string to concatenate.Number of bytes written."}]},"kind":"stock","returnType":"int","arguments":[{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlength","decl":"int maxlength"},{"type":"const char[]","name":"source","decl":"const char[] source"}]},{"name":"ExplodeString","docStart":17131,"docEnd":17754,"docs":{"brief":"Breaks a string into pieces and stores each piece into an array of buffers.","tags":[{"tag":"","text":"Breaks a string into pieces and stores each piece into an array of buffers."},{"tag":"param:text","text":"Breaks a string into pieces and stores each piece into an array of buffers.\nThe string to split."},{"tag":"param:split","text":"Breaks a string into pieces and stores each piece into an array of buffers.\nThe string to split.The string to use as a split delimiter."},{"tag":"param:buffers","text":"Breaks a string into pieces and stores each piece into an array of buffers.\nThe string to split.The string to use as a split delimiter.An array of string buffers (2D array)."},{"tag":"param:maxStrings","text":"Breaks a string into pieces and stores each piece into an array of buffers.\nThe string to split.The string to use as a split delimiter.An array of string buffers (2D array).Number of string buffers (first dimension size)."},{"tag":"param:maxStringLength","text":"Breaks a string into pieces and stores each piece into an array of buffers.\nThe string to split.The string to use as a split delimiter.An array of string buffers (2D array).Number of string buffers (first dimension size).Maximum length of each string buffer."},{"tag":"param:copyRemainder","text":"Breaks a string into pieces and stores each piece into an array of buffers.\nThe string to split.The string to use as a split delimiter.An array of string buffers (2D array).Number of string buffers (first dimension size).Maximum length of each string buffer.False (default) discard excess pieces, true to ignoredelimiters after last piece."},{"tag":"return","text":"Breaks a string into pieces and stores each piece into an array of buffers.\nThe string to split.The string to use as a split delimiter.An array of string buffers (2D array).Number of string buffers (first dimension size).Maximum length of each string buffer.False (default) discard excess pieces, true to ignoredelimiters after last piece.Number of strings retrieved."}]},"kind":"stock","returnType":"int","arguments":[{"type":"const char[]","name":"text","decl":"const char[] text"},{"type":"const char[]","name":"split","decl":"const char[] split"},{"type":"char[][]","name":"buffers","decl":"char[][] buffers"},{"type":"int","name":"maxStrings","decl":"int maxStrings"},{"type":"int","name":"maxStringLength","decl":"int maxStringLength"},{"type":"bool","name":"copyRemainder","decl":"bool copyRemainder"}]},{"name":"ImplodeStrings","docStart":18389,"docEnd":18932,"docs":{"brief":"Joins an array of strings into one string, with a \"join\" string inserted inbetween each given string.  This function complements ExplodeString.","tags":[{"tag":"","text":"Joins an array of strings into one string, with a \"join\" string inserted inbetween each given string.  This function complements ExplodeString."},{"tag":"param:strings","text":"Joins an array of strings into one string, with a \"join\" string inserted inbetween each given string.  This function complements ExplodeString.\nAn array of strings."},{"tag":"param:numStrings","text":"Joins an array of strings into one string, with a \"join\" string inserted inbetween each given string.  This function complements ExplodeString.\nAn array of strings.Number of strings in the array."},{"tag":"param:join","text":"Joins an array of strings into one string, with a \"join\" string inserted inbetween each given string.  This function complements ExplodeString.\nAn array of strings.Number of strings in the array.The join string to insert between each string."},{"tag":"param:buffer","text":"Joins an array of strings into one string, with a \"join\" string inserted inbetween each given string.  This function complements ExplodeString.\nAn array of strings.Number of strings in the array.The join string to insert between each string.Output buffer to write the joined string to."},{"tag":"param:maxLength","text":"Joins an array of strings into one string, with a \"join\" string inserted inbetween each given string.  This function complements ExplodeString.\nAn array of strings.Number of strings in the array.The join string to insert between each string.Output buffer to write the joined string to.Maximum length of the output buffer."},{"tag":"return","text":"Joins an array of strings into one string, with a \"join\" string inserted inbetween each given string.  This function complements ExplodeString.\nAn array of strings.Number of strings in the array.The join string to insert between each string.Output buffer to write the joined string to.Maximum length of the output buffer.Number of bytes written to the output buffer."}]},"kind":"stock","returnType":"int","arguments":[{"type":"const char[][]","name":"strings","decl":"const char[][] strings"},{"type":"int","name":"numStrings","decl":"int numStrings"},{"type":"const char[]","name":"join","decl":"const char[] join"},{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxLength","decl":"int maxLength"}]}],"methodmaps":[],"constants":[],"enums":[],"typesets":[],"typedefs":[]}