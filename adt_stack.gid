{"functions":[{"name":"CreateStack","docStart":4859,"docEnd":5606,"docs":{"brief":"Creates a stack structure.  A stack is a LIFO (last in, first out)vector (array) of items.  It has O(1) insertion and O(1) removal.\nStacks have two operations: Push (adding an item) and Pop (removesitems in reverse-push order).\nThe contents of the stack are uniform; i.e. storing a string and thenretrieving it as an integer is NOT the same as StringToInt()!\nThe \"blocksize\" determines how many cells each slot has; it cannotbe changed after creation.","tags":[{"tag":"","text":"Creates a stack structure.  A stack is a LIFO (last in, first out)vector (array) of items.  It has O(1) insertion and O(1) removal.\nStacks have two operations: Push (adding an item) and Pop (removesitems in reverse-push order).\nThe contents of the stack are uniform; i.e. storing a string and thenretrieving it as an integer is NOT the same as StringToInt()!\nThe \"blocksize\" determines how many cells each slot has; it cannotbe changed after creation."},{"tag":"param:blocksize","text":"Creates a stack structure.  A stack is a LIFO (last in, first out)vector (array) of items.  It has O(1) insertion and O(1) removal.\nStacks have two operations: Push (adding an item) and Pop (removesitems in reverse-push order).\nThe contents of the stack are uniform; i.e. storing a string and thenretrieving it as an integer is NOT the same as StringToInt()!\nThe \"blocksize\" determines how many cells each slot has; it cannotbe changed after creation.\nThe number of cells each entry in the stack canhold.  For example, 32 cells is equivalent to:new Array[X][32]"},{"tag":"return","text":"Creates a stack structure.  A stack is a LIFO (last in, first out)vector (array) of items.  It has O(1) insertion and O(1) removal.\nStacks have two operations: Push (adding an item) and Pop (removesitems in reverse-push order).\nThe contents of the stack are uniform; i.e. storing a string and thenretrieving it as an integer is NOT the same as StringToInt()!\nThe \"blocksize\" determines how many cells each slot has; it cannotbe changed after creation.\nThe number of cells each entry in the stack canhold.  For example, 32 cells is equivalent to:new Array[X][32]New stack Handle."}]},"kind":"native","returnType":"ArrayStack","arguments":[{"type":"int","name":"blocksize","decl":"int blocksize"}]},{"name":"PushStackCell","docStart":5659,"docEnd":5960,"docs":{"brief":"Pushes a value onto the end of the stack, adding a new index.\nThis may safely be used even if the stack has a blocksizegreater than 1.","tags":[{"tag":"","text":"Pushes a value onto the end of the stack, adding a new index.\nThis may safely be used even if the stack has a blocksizegreater than 1."},{"tag":"param:stack","text":"Pushes a value onto the end of the stack, adding a new index.\nThis may safely be used even if the stack has a blocksizegreater than 1.\nStack Handle."},{"tag":"param:value","text":"Pushes a value onto the end of the stack, adding a new index.\nThis may safely be used even if the stack has a blocksizegreater than 1.\nStack Handle.Value to push."},{"tag":"error","text":"Pushes a value onto the end of the stack, adding a new index.\nThis may safely be used even if the stack has a blocksizegreater than 1.\nStack Handle.Value to push.Invalid Handle or out of memory."}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"stack","decl":"Handle stack"},{"type":"any","name":"value","decl":"any value"}]},{"name":"PushStackString","docStart":6017,"docEnd":6259,"docs":{"brief":"Pushes a copy of a string onto the end of a stack, truncating it if it istoo big.","tags":[{"tag":"","text":"Pushes a copy of a string onto the end of a stack, truncating it if it istoo big."},{"tag":"param:stack","text":"Pushes a copy of a string onto the end of a stack, truncating it if it istoo big.\nStack Handle."},{"tag":"param:value","text":"Pushes a copy of a string onto the end of a stack, truncating it if it istoo big.\nStack Handle.String to push."},{"tag":"error","text":"Pushes a copy of a string onto the end of a stack, truncating it if it istoo big.\nStack Handle.String to push.Invalid Handle or out of memory."}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"stack","decl":"Handle stack"},{"type":"const char[]","name":"value","decl":"const char[] value"}]},{"name":"PushStackArray","docStart":6327,"docEnd":6917,"docs":{"brief":"Pushes a copy of an array of cells onto the end of a stack.  The cellsare pushed as a block (i.e. the entire array takes up one stack slot),rather than pushing each cell individually.","tags":[{"tag":"","text":"Pushes a copy of an array of cells onto the end of a stack.  The cellsare pushed as a block (i.e. the entire array takes up one stack slot),rather than pushing each cell individually."},{"tag":"param:stack","text":"Pushes a copy of an array of cells onto the end of a stack.  The cellsare pushed as a block (i.e. the entire array takes up one stack slot),rather than pushing each cell individually.\nStack Handle."},{"tag":"param:values","text":"Pushes a copy of an array of cells onto the end of a stack.  The cellsare pushed as a block (i.e. the entire array takes up one stack slot),rather than pushing each cell individually.\nStack Handle.Block of values to copy."},{"tag":"param:size","text":"Pushes a copy of an array of cells onto the end of a stack.  The cellsare pushed as a block (i.e. the entire array takes up one stack slot),rather than pushing each cell individually.\nStack Handle.Block of values to copy.If not set, the number of elements copied from the arraywill be equal to the blocksize.  If set higher than theblocksize, the operation will be truncated."},{"tag":"error","text":"Pushes a copy of an array of cells onto the end of a stack.  The cellsare pushed as a block (i.e. the entire array takes up one stack slot),rather than pushing each cell individually.\nStack Handle.Block of values to copy.If not set, the number of elements copied from the arraywill be equal to the blocksize.  If set higher than theblocksize, the operation will be truncated.Invalid Handle or out of memory."}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"stack","decl":"Handle stack"},{"type":"const any[]","name":"values","decl":"const any[] values"},{"type":"int","name":"size","decl":"int size"}]},{"name":"PopStackCell","docStart":6997,"docEnd":7445,"docs":{"brief":"Pops a cell value from a stack.","tags":[{"tag":"","text":"Pops a cell value from a stack."},{"tag":"param:stack","text":"Pops a cell value from a stack.\nStack Handle."},{"tag":"param:value","text":"Pops a cell value from a stack.\nStack Handle.Variable to store the value."},{"tag":"param:block","text":"Pops a cell value from a stack.\nStack Handle.Variable to store the value.Optionally specify which block to read from(useful if the blocksize > 0)."},{"tag":"param:asChar","text":"Pops a cell value from a stack.\nStack Handle.Variable to store the value.Optionally specify which block to read from(useful if the blocksize > 0).Optionally read as a byte instead of a cell."},{"tag":"return","text":"Pops a cell value from a stack.\nStack Handle.Variable to store the value.Optionally specify which block to read from(useful if the blocksize > 0).Optionally read as a byte instead of a cell.True on success, false if the stack is empty."},{"tag":"error","text":"Pops a cell value from a stack.\nStack Handle.Variable to store the value.Optionally specify which block to read from(useful if the blocksize > 0).Optionally read as a byte instead of a cell.True on success, false if the stack is empty.Invalid Handle."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"stack","decl":"Handle stack"},{"type":"any&","name":"value","decl":"any& value"},{"type":"int","name":"block","decl":"int block"},{"type":"bool","name":"asChar","decl":"bool asChar"}]},{"name":"PopStackString","docStart":7534,"docEnd":7837,"docs":{"brief":"Pops a string value from a stack.","tags":[{"tag":"","text":"Pops a string value from a stack."},{"tag":"param:stack","text":"Pops a string value from a stack.\nStack Handle."},{"tag":"param:buffer","text":"Pops a string value from a stack.\nStack Handle.Buffer to store string."},{"tag":"param:maxlength","text":"Pops a string value from a stack.\nStack Handle.Buffer to store string.Maximum size of the buffer."},{"tag":"return","text":"Pops a string value from a stack.\nStack Handle.Buffer to store string.Maximum size of the buffer.True on success, false if the stack is empty."},{"tag":"error","text":"Pops a string value from a stack.\nStack Handle.Buffer to store string.Maximum size of the buffer.True on success, false if the stack is empty.Invalid Handle."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"stack","decl":"Handle stack"},{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlength","decl":"int maxlength"},{"type":"int&","name":"written","decl":"int& written"}]},{"name":"PopStackArray","docStart":7930,"docEnd":8339,"docs":{"brief":"Pops an array of cells from a stack.","tags":[{"tag":"","text":"Pops an array of cells from a stack."},{"tag":"param:stack","text":"Pops an array of cells from a stack.\nStack Handle."},{"tag":"param:buffer","text":"Pops an array of cells from a stack.\nStack Handle.Buffer to store the array in."},{"tag":"param:size","text":"Pops an array of cells from a stack.\nStack Handle.Buffer to store the array in.If not set, assumes the buffer size is equal to theblocksize.  Otherwise, the size passed is used."},{"tag":"return","text":"Pops an array of cells from a stack.\nStack Handle.Buffer to store the array in.If not set, assumes the buffer size is equal to theblocksize.  Otherwise, the size passed is used.True on success, false if the stack is empty."},{"tag":"error","text":"Pops an array of cells from a stack.\nStack Handle.Buffer to store the array in.If not set, assumes the buffer size is equal to theblocksize.  Otherwise, the size passed is used.True on success, false if the stack is empty.Invalid Handle."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"stack","decl":"Handle stack"},{"type":"any[]","name":"buffer","decl":"any[] buffer"},{"type":"int","name":"size","decl":"int size"}]},{"name":"IsStackEmpty","docStart":8412,"docEnd":8596,"docs":{"brief":"Checks if a stack is empty.","tags":[{"tag":"","text":"Checks if a stack is empty."},{"tag":"param:stack","text":"Checks if a stack is empty.\nStack Handle."},{"tag":"return","text":"Checks if a stack is empty.\nStack Handle.True if empty, false if not empty."},{"tag":"error","text":"Checks if a stack is empty.\nStack Handle.True if empty, false if not empty.Invalid Handle."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"stack","decl":"Handle stack"}]},{"name":"PopStack","docStart":8641,"docEnd":8859,"docs":{"brief":"Pops a value off a stack, ignoring it completely.","tags":[{"tag":"","text":"Pops a value off a stack, ignoring it completely."},{"tag":"param:stack","text":"Pops a value off a stack, ignoring it completely.\nStack Handle."},{"tag":"return","text":"Pops a value off a stack, ignoring it completely.\nStack Handle.True if something was popped, false otherwise."},{"tag":"error","text":"Pops a value off a stack, ignoring it completely.\nStack Handle.True if something was popped, false otherwise.Invalid Handle."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"Handle","name":"stack","decl":"Handle stack"}]},{"name":"GetStackBlockSize","docStart":8954,"docEnd":9152,"docs":{"brief":"Returns the blocksize the stack was created with.","tags":[{"tag":"","text":"Returns the blocksize the stack was created with."},{"tag":"param:stack","text":"Returns the blocksize the stack was created with.\nStack Handle."},{"tag":"return","text":"Returns the blocksize the stack was created with.\nStack Handle.The blocksize of the stack."},{"tag":"error","text":"Returns the blocksize the stack was created with.\nStack Handle.The blocksize of the stack.Invalid Handle"}]},"kind":"native","returnType":"int","arguments":[{"type":"Handle","name":"stack","decl":"Handle stack"}]}],"methodmaps":[{"name":"ArrayStack","docStart":0,"docEnd":0,"docs":null,"methods":[{"name":"ArrayStack","docStart":1696,"docEnd":2401,"docs":{"brief":"Creates a stack structure.  A stack is a LIFO (last in, first out)vector (array) of items.  It has O(1) insertion and O(1) removal.\nStacks have two operations: Push (adding an item) and Pop (removesitems in reverse-push order).\nThe contents of the stack are uniform; i.e. storing a string and thenretrieving it as an integer is NOT the same as StringToInt()!\nThe \"blocksize\" determines how many cells each slot has; it cannotbe changed after creation.","tags":[{"tag":"","text":"Creates a stack structure.  A stack is a LIFO (last in, first out)vector (array) of items.  It has O(1) insertion and O(1) removal.\nStacks have two operations: Push (adding an item) and Pop (removesitems in reverse-push order).\nThe contents of the stack are uniform; i.e. storing a string and thenretrieving it as an integer is NOT the same as StringToInt()!\nThe \"blocksize\" determines how many cells each slot has; it cannotbe changed after creation."},{"tag":"param:blocksize","text":"Creates a stack structure.  A stack is a LIFO (last in, first out)vector (array) of items.  It has O(1) insertion and O(1) removal.\nStacks have two operations: Push (adding an item) and Pop (removesitems in reverse-push order).\nThe contents of the stack are uniform; i.e. storing a string and thenretrieving it as an integer is NOT the same as StringToInt()!\nThe \"blocksize\" determines how many cells each slot has; it cannotbe changed after creation.\nThe number of cells each entry in the stack canhold.  For example, 32 cells is equivalent to:new Array[X][32"}]},"kind":null,"returnType":"ArrayStack","arguments":[{"type":"int","name":"blocksize","decl":"int blocksize"}]},{"name":"Push","docStart":2451,"docEnd":2649,"docs":{"brief":"Pushes a value onto the end of the stack, adding a new index.\nThis may safely be used even if the stack has a blocksizegreater than 1.","tags":[{"tag":"","text":"Pushes a value onto the end of the stack, adding a new index.\nThis may safely be used even if the stack has a blocksizegreater than 1."},{"tag":"param:value","text":"Pushes a value onto the end of the stack, adding a new index.\nThis may safely be used even if the stack has a blocksizegreater than 1.\nValue to push"}]},"kind":null,"returnType":"void","arguments":[{"type":"any","name":"value","decl":"any value"}]},{"name":"PushString","docStart":2692,"docEnd":2828,"docs":{"brief":"Pushes a copy of a string onto the end of a stack, truncating it if itis too big.","tags":[{"tag":"","text":"Pushes a copy of a string onto the end of a stack, truncating it if itis too big."},{"tag":"param:value","text":"Pushes a copy of a string onto the end of a stack, truncating it if itis too big.\nString to push"}]},"kind":null,"returnType":"void","arguments":[{"type":"const char[]","name":"value","decl":"const char[] value"}]},{"name":"PushArray","docStart":2886,"docEnd":3410,"docs":{"brief":"Pushes a copy of an array of cells onto the end of a stack. The cellsare pushed as a block (i.e. the entire array takes up one stack slot),rather than pushing each cell individually.","tags":[{"tag":"","text":"Pushes a copy of an array of cells onto the end of a stack. The cellsare pushed as a block (i.e. the entire array takes up one stack slot),rather than pushing each cell individually."},{"tag":"param:stack","text":"Pushes a copy of an array of cells onto the end of a stack. The cellsare pushed as a block (i.e. the entire array takes up one stack slot),rather than pushing each cell individually.\nStack Handle."},{"tag":"param:values","text":"Pushes a copy of an array of cells onto the end of a stack. The cellsare pushed as a block (i.e. the entire array takes up one stack slot),rather than pushing each cell individually.\nStack Handle.Block of values to copy."},{"tag":"param:size","text":"Pushes a copy of an array of cells onto the end of a stack. The cellsare pushed as a block (i.e. the entire array takes up one stack slot),rather than pushing each cell individually.\nStack Handle.Block of values to copy.If not set, the number of elements copied from the arraywill be equal to the blocksize.  If set higher than theblocksize, the operation will be truncated"}]},"kind":null,"returnType":"void","arguments":[{"type":"const any[]","name":"values","decl":"const any[] values"},{"type":"int","name":"size","decl":"int size"}]},{"name":"Pop","docStart":3480,"docEnd":3813,"docs":{"brief":"Pops a cell value from a stack.","tags":[{"tag":"","text":"Pops a cell value from a stack."},{"tag":"param:block","text":"Pops a cell value from a stack.\nOptionally specify which block to read from(useful if the blocksize > 0)."},{"tag":"param:asChar","text":"Pops a cell value from a stack.\nOptionally specify which block to read from(useful if the blocksize > 0).Optionally read as a byte instead of a cell."},{"tag":"return","text":"Pops a cell value from a stack.\nOptionally specify which block to read from(useful if the blocksize > 0).Optionally read as a byte instead of a cell.Value popped from the stack."},{"tag":"error","text":"Pops a cell value from a stack.\nOptionally specify which block to read from(useful if the blocksize > 0).Optionally read as a byte instead of a cell.Value popped from the stack.The stack is empty"}]},"kind":null,"returnType":"any","arguments":[{"type":"int","name":"block","decl":"int block"},{"type":"bool","name":"asChar","decl":"bool asChar"}]},{"name":"PopString","docStart":3875,"docEnd":4188,"docs":{"brief":"Pops a string value from a stack.","tags":[{"tag":"","text":"Pops a string value from a stack."},{"tag":"param:buffer","text":"Pops a string value from a stack.\nBuffer to store string."},{"tag":"param:maxlength","text":"Pops a string value from a stack.\nBuffer to store string.Maximum size of the buffer."},{"tag":"param:written","text":"Pops a string value from a stack.\nBuffer to store string.Maximum size of the buffer.Number of characters written to buffer, not includingthe null terminator."},{"tag":"error","text":"Pops a string value from a stack.\nBuffer to store string.Maximum size of the buffer.Number of characters written to buffer, not includingthe null terminator.The stack is empty"}]},"kind":null,"returnType":"void","arguments":[{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlength","decl":"int maxlength"},{"type":"int&","name":"written","decl":"int& written"}]},{"name":"PopArray","docStart":4273,"docEnd":4567,"docs":{"brief":"Pops an array of cells from a stack.","tags":[{"tag":"","text":"Pops an array of cells from a stack."},{"tag":"param:buffer","text":"Pops an array of cells from a stack.\nBuffer to store the array in."},{"tag":"param:size","text":"Pops an array of cells from a stack.\nBuffer to store the array in.If not set, assumes the buffer size is equal to theblocksize.  Otherwise, the size passed is used."},{"tag":"error","text":"Pops an array of cells from a stack.\nBuffer to store the array in.If not set, assumes the buffer size is equal to theblocksize.  Otherwise, the size passed is used.The stack is empty"}]},"kind":null,"returnType":"void","arguments":[{"type":"any[]","name":"buffer","decl":"any[] buffer"},{"type":"int","name":"size","decl":"int size"}]}],"properties":[{"name":"Empty","docStart":4630,"docEnd":4685,"docs":{"brief":"Returns true if the stack is empty, false otherwise","tags":[{"tag":"","text":"Returns true if the stack is empty, false otherwise"}]},"type":"bool","getter":true,"setter":false},{"name":"BlockSize","docStart":4743,"docEnd":4796,"docs":{"brief":"Retrieve the blocksize the stack was created with","tags":[{"tag":"","text":"Retrieve the blocksize the stack was created with"}]},"type":"int","getter":true,"setter":false}]}],"constants":[],"enums":[],"typesets":[],"typedefs":[]}